<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>EmptyNode</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">EmptyNode</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/" class="current">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" style="display:none;" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/02/08/Design-Pattern-Proxy-Pattern/">Design Pattern-Proxy Pattern</a></h3></div><div class="post-content"><p>概述
代理模式简单来说就是以一种间接的方式来实现对对象的引用(当Client不希望自身直接引用对象的时候)，利用代理对象实现一种中介的作用。

通过加入一个新的代理对象来对真实的对象进行操作或者把代理的对象当作一个真实的对象的替身，这种机制就可以称为代理模式，即由代理对象来完成对一个对象的访问。



设计结构代...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-02-08</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Design-Pattern/" title="Design Pattern" class="tag">Design Pattern </a><a href="/tags/Java/" title="Java" class="tag">Java </a><a href="/tags/Android/" title="Android" class="tag">Android </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/02/02/Java-Programming-Multithreading-Episode-2/">Java Programming-Multithreading(Episode 2)</a></h3></div><div class="post-content"><p>
在本节当中将主要介绍java当中的线程的中断以及线程的各种状态转换等内容

中断线程当方法当中出现了没有捕获的异常的时候，线程一般来说都会终止。对于早期版本的java的SDK存在着一个stop()方法用来对线程进行终止，但是这个方法已经被弃用。
当在java当中对一个线程使用interrupt方法的时候，对应线...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-02-02</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Java/" title="Java" class="tag">Java </a><a href="/tags/Multithreading/" title="Multithreading" class="tag">Multithreading </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/01/20/Design-Pattern-Observer-Pattern/">Design Pattern-Observer Pattern</a></h3></div><div class="post-content"><p>概述
观察者模式(Observer Pattern)在处理软件设计当中，对象存在这一对多的关系的时候是非常*有效的。比如在一个对象的状态被修改的时候，其他和它绑定的对象便会得到它的通知，这个行为也和我们在Android中经常用到的回调机制是相类似的。观察者模式同时也被称为发布-订阅模式(Publish/Subsc...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-20</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Design-Pattern/" title="Design Pattern" class="tag">Design Pattern </a><a href="/tags/Java/" title="Java" class="tag">Java </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/01/16/Java-Programming-Multithreading/">Java Programming-Multithreading(Episode 1)</a></h3></div><div class="post-content"><p>进程和线程
对于进程和线程等概念，我们经常可以在一些涉及操作系统的书籍当中了解到相关的内容。诸如在电脑或者智能手机等设备上，很多操作都是可以并行执行的，eg:在浏览网页的时候听音乐，在编写文档的时候进行后台的图片下载。这些情境都是多任务(Multitasking)功能为我们的生活带来的便利。
多进程和多线程的主要...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-16</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Java/" title="Java" class="tag">Java </a><a href="/tags/Multithreading/" title="Multithreading" class="tag">Multithreading </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2017/01/05/Algorithm-MST-Shortest-Path/">Algorithm-MST, Shortest Path</a></h3></div><div class="post-content"><p>最小生成树加权图
在直接讨论最小生成树之前，首先介绍加权图这个概念，这是一种每条边关联一个权值的基于图的模型，在实际生活中有很多加权图的应用，比如地图当中的路径长度。


MST 概念
生成树表示的是一棵含有图中所有顶点的一个无环连通子图，而最小生成树又称最小权重生成树是加权图当中一棵权值和最小的生成树。

MS...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-05</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Data-Structure/" title="Data Structure" class="tag">Data Structure </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2016/12/31/Design-Pattern-Adapter-Pattern/">Design Pattern-Adapter Pattern</a></h3></div><div class="post-content"><p>产生动机
在软件开发当中，适配器模式(Adapter Pattern)正如其名，非常类似于我们生活当中的电源适配器(可将交流电压转化为正常工作电压)
在实际的编程当中，Client一般可以通过目标类的接口访问它提供的各种服务，有的时候现有的类能够满足客户对某个功能的要求，但是它提供的接口并不是客户所期望的，原因可...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-31</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Design-Pattern/" title="Design Pattern" class="tag">Design Pattern </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2016/12/30/Algorithm-Graph/">Algorithm-Graph</a></h3></div><div class="post-content"><p>Graph (图)
简单来说，图 G(V,E)是由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成的。同时根据边是否有向还可以把图分为有向图和无向图。当对图中的边赋予某些数值的时候(比如每条边对应的路径长度)，这时候又可以分为有权重和无权重图。


图相关概念
Vertex: 图当中用于连接的...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-30</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Data-Structure/" title="Data Structure" class="tag">Data Structure </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2016/12/28/Design-Pattern-Factory-Method/">Design Pattern-Factory Pattern</a></h3></div><div class="post-content"><p>概念
一种实现了“工厂”概念的面向对象的设计模式。和其他的创建型模式Template Method一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。该模式的实质实际上是”定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。因此工厂方法的作用就是将实例化进程推迟到子类当中进行”。在对象创建过程...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-28</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Design-Pattern/" title="Design Pattern" class="tag">Design Pattern </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2016/12/22/Design Pattern-Singleton/">Design Pattern-Singleton Pattern</a></h3></div><div class="post-content"><p>概述在软件工程当中，设计模式 (Design Pattern) 是对软件设计当中普遍存在的各种问题，所得出的解决方案。设计模式并不是直接用来完成代码的编写，而是描述在不同的状况下，要如何解决问题的一种方案。

面向对象设计模式通常以类别或者对象来描述其中的关系和相互作用， 但不涉及用来完成应用程序的特定类别或者对...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-22</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Design-Pattern/" title="Design Pattern" class="tag">Design Pattern </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2016/12/19/Algorithm-Searching/">Algorithm-Searching</a></h3></div><div class="post-content"><p>Symbol Table (符号表)
定义： 符号表是一种可以存储key-value的数据结构，它可以进行两种操作，put(将键值对存入符号表)和get操作(根据给定的key查找value)，就相当于字典查询一样，需要通过索引进行对应查找


Base API123456789public class Symbo...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-19</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Data-Structure/" title="Data Structure" class="tag">Data Structure </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/page/2/" class="btn">下一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>