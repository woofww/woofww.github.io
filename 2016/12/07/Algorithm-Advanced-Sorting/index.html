<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Algorithm-Advanced Sorting · EmptyNode</title><meta name="description" content="归并排序
复杂度(nlogn)

概念
对于归并的概念，简而言之就是分治，对于独立的部分单独地进行排序然后再将排序完成的子数组进行合并，最终完成全部排序。但是归并排序由于需要额外数组，所以空间复杂度也比较高。




样例
  


分类原地归并的抽象方法
Example:
  

原地归并为直接将"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">EmptyNode</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Algorithm-Advanced Sorting</a></h3></div><div class="post-content"><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>对于归并的概念，简而言之就是分治，对于独立的部分单独地进行排序然后再将排序完成的子数组进行合并，最终完成全部排序。但是归并排序由于需要额外数组，所以空间复杂度也比较高。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/merge-sort_8993d8.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h4><ul>
<li><p>Example:</p>
<p>  <img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt="enter image description here"></p>
</li>
<li><p>原地归并为直接将两个不同的有序数组合并到第三个数组当中，当然该数组最终是有序的。原理：首先将原数组存放至一个临时数组当中，并通过指定参数如i和j指向数组的起始位置<code>low</code>和中间位置<code>middle</code>。以此保证了原数组左右两边是有序的。从左右两个独立数组的头部开始扫描数组，此时对<code>array[i]</code>和<code>array[j]</code>进行比较，将较大值放入临时数组。</p>
</li>
</ul>
<ul>
<li>抽象地描述便是<code>merge(a, low, middle, high)</code>，该方法会将<code>a[low..middle]</code>，<code>a[middle..high]</code>归并为一个有序的数组并将结果存放在<code>a[low..high]</code>当中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data_new = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</div><div class="line">        <span class="keyword">int</span> left = low, right = middle+<span class="number">1</span>; <span class="comment">// 定义双指针</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= data.length-<span class="number">1</span> ; i++ ) &#123;</div><div class="line">            data_new[i] = data[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= high; i++ ) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; middle) data[i] = data_new[right++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high ) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data_new[left] &lt; data_new[right]) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> data[i] = data_new[right++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h4><p>自顶向下排序实现了一种递归归并的方法， 实现了一种典型的分治思想，运用迭代的思想将两个独立的子数组进行排序，并最终完成归并；对于一个长度为N的任意数组， 自顶向下归并排序需要进行1/2NloN到NlgN的比较</p>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;<span class="comment">//此种情况结束递归，即无法再继续进行分割</span></div><div class="line">    <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;</div><div class="line">    sort(data, low, middle);<span class="comment">//对数组左半部分进行排序</span></div><div class="line">    sort(data, middle+<span class="number">1</span>, high);<span class="comment">//对右半部份进行排序</span></div><div class="line">    merge(data, low, middle, high);<span class="comment">//不断进行递归，直到无法继续进行直到结束</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><ul>
<li><p>对于规模较小的子数组使用插入排序</p>
<p>由于归并排序中频繁的使用了递归的方式进行操作，操作过程中对于一些小规模的数组，可以先对其进行插入排序，因为对于子数组(长度小于15)的排序，插入排序的效率会更高一些，运行时间一般可以缩短10%到15%。</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  在merge之前先对数组进行判断是否已经有序，如果有序则直接跳过merge步骤</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!data[i+<span class="number">1</span>] &lt; data[i] ) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>快速排序同样属于一种分治算法，将一个数组分为两个子数组，然后将两部分进行独立的排序。</p>
<blockquote>
<p>和归并排序的区别：对于归并排序是先对独立的子数组进行排序，然后在将排序后的子数组进行归并而将整个数组进行排序。快速排序在将子数组排序之后，整体数组也同时完成了排序。</p>
</blockquote>
<p><img src="http://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort_b49af5.gif" alt="enter image description here"></p>
</li>
<li><p>步骤</p>
<ol>
<li>对数组进行shuffle，保证快速排序的性能</li>
<li>切分数组(需要满足如下条件)<ul>
<li>对于某个<code>j</code>, <code>a[j]</code>已经排定</li>
<li><code>a[low]</code>到<code>a[j-1]</code>的所有元素都不大于<code>a[j]</code></li>
<li><code>a[j+1]</code>到<code>a[high]</code>的所有元素都不小于<code>a[j]</code></li>
</ul>
</li>
<li>递归的对数组进行排序</li>
</ol>
</li>
<li><p>切分(Partition)</p>
<p>  切分操作一般都选择数组的第一个元素作为切分元素，下一步从数组的左侧向右扫描，直到发现大于切分元素即跳出扫描循环。另一部分从数组的右侧向左扫描，当发现小于切分元素即跳出第二个扫描循环。当扫描指针相遇的时候，跳出大循环。</p>
<p>  <img src="http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png" alt="enter image description here"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;<span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//从数组两侧进行扫描</span></div><div class="line">        <span class="keyword">while</span>(data[++i] &lt; compare) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;<span class="comment">//当左指针大于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">while</span> (compare &lt; data[--j]) <span class="keyword">if</span> (j == low) <span class="keyword">break</span>;<span class="comment">//当右指针小于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;<span class="comment">//当左右指针相遇的时候，跳出循环体</span></div><div class="line">        <span class="comment">//元素交换</span></div><div class="line">        temp = data[i];</div><div class="line">        data[i] = data[j];</div><div class="line">        data[j] = temp;</div><div class="line">    &#125;</div><div class="line">    temp = data[low];</div><div class="line">    data[low] = data[j];</div><div class="line">    data[j] = temp;</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">    <span class="comment">//将首元素和位置[j]的元素进行交换</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="改善快速排序性能的简单方法"><a href="#改善快速排序性能的简单方法" class="headerlink" title="改善快速排序性能的简单方法"></a>改善快速排序性能的简单方法</h4><ul>
<li>类似于归并排序，对于小数组，插入排序的效率更高一些</li>
<li><p>由于递归的原因，排序方法也会在小数组当中调用自己</p>
</li>
<li><p>三取样切分</p>
<ul>
<li>通过使用子数组一部分元素的中位数来对数组进行切分。</li>
</ul>
</li>
</ul>
<h4 id="三向切分-熵最优排序"><a href="#三向切分-熵最优排序" class="headerlink" title="三向切分(熵最优排序)"></a>三向切分(熵最优排序)</h4><p>Example:</p>
<p><img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort-3-way_d176ee.gif" alt="enter image description here"></p>
<p>该情况适用于数组当中存在大量重复元素的样例。当切分的元素重复的时候，不需要对其进行排序即可。切分的三部分分别为大于小于等于元素的数组元素</p>
<ul>
<li><code>data[i]</code> &lt; <code>compare</code>元素 二者交换 <code>i</code> 和 <code>lt</code>同时增加</li>
<li><code>data[i]</code> &gt; <code>compare</code>元素 和<code>data[gt]``交换</code>gt`减少</li>
<li><code>data[i]</code> = <code>compare</code>元素 <code>i++</code></li>
</ul>
<p>这样的操作能够保证数组元素不变，同时缩小<code>gt</code>-<code>i</code>的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threeWaySort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>; <span class="comment">//递归结束条件</span></div><div class="line">    <span class="keyword">int</span> lt = low, i = low + <span class="number">1</span>, gt = high; <span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (i &lt;= gt)&#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[lt];</div><div class="line">            data[lt] = temp;</div><div class="line">            i++;</div><div class="line">            lt++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[gt];</div><div class="line">            data[gt] = temp;</div><div class="line">            gt--;</div><div class="line">        &#125;<span class="keyword">else</span> i++;</div><div class="line">    &#125;</div><div class="line">    threeWaySort(data, low, lt-<span class="number">1</span>);</div><div class="line">    threeWaySort(data, gt+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/heap-sort_f79bb1.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>二叉堆一种可以有效支持优先队列操作的数据结构。在二叉堆数组当中，每个元素都应该保证大于等于另外两个特定位置的元素，以此类推。二叉堆是一组能够用堆有序的完全二叉树排序的元素，其在数组当中按层级排列。</p>
<p>Example:</p>
<p><img src="http://algs4.cs.princeton.edu/24pq/images/heap-representations.png" alt="enter image description here"></p>
<h3 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h3><ul>
<li><p>通过使用优先队列构造排序方法，将所有的元素插入到查找最小元素的优先队列当中，堆排序主要包含两个部分，1. 将原始数组构造为有序堆 2. 不断将根节点移出树结构，同时重新构造有序堆。</p>
<ul>
<li><p>堆的构造</p>
<p>通过对数据从右至左进行不断的sink操作，对于数组中的每一个位置，都能够认为是每个子堆的根节点(也包含树的最底层节点)。对于扫描数组只需要扫描其容量的一半，这样可以跳过大小为1的子堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N = data.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- ) &#123;</div><div class="line">        sink(data, i, N);<span class="comment">//该部分目的构造有序堆</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</div><div class="line">        exchange(data, <span class="number">1</span>, N--);</div><div class="line">        sink(data, <span class="number">1</span>, N);</div><div class="line">        <span class="comment">//移出每个堆中的最大元素，完成排序</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="排序算法复杂度总结"><a href="#排序算法复杂度总结" class="headerlink" title="排序算法复杂度总结"></a>排序算法复杂度总结</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316203033.jpg" alt="enter image description here"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-07</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://woofww.github.io/2016/12/07/Algorithm-Advanced-Sorting/,EmptyNode,Algorithm-Advanced Sorting,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/12/19/Algorithm-Searching/" title="Algorithm-Searching" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/11/28/Algorithm-Sorting/" title="Algorithm-Elementary Sorting" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>