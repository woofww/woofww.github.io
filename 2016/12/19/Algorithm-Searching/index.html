<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Algorithm-Searching · EmptyNode</title><meta name="description" content="Symbol Table (符号表)
定义： 符号表是一种可以存储key-value的数据结构，它可以进行两种操作，put(将键值对存入符号表)和get操作(根据给定的key查找value)，就相当于字典查询一样，需要通过索引进行对应查找


Base API123456789public clas"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">EmptyNode</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Algorithm-Searching</a></h3></div><div class="post-content"><h2 id="Symbol-Table-符号表"><a href="#Symbol-Table-符号表" class="headerlink" title="Symbol Table (符号表)"></a>Symbol Table (符号表)</h2><blockquote>
<p>定义： 符号表是一种可以存储<code>key-value</code>的数据结构，它可以进行两种操作，<code>put</code>(将键值对存入符号表)和<code>get</code>操作(根据给定的<code>key</code>查找<code>value</code>)，就相当于字典查询一样，需要通过索引进行对应查找</p>
</blockquote>
<a id="more"></a>
<h3 id="Base-API"><a href="#Base-API" class="headerlink" title="Base API"></a>Base API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class SymbolTable&lt;key,value&gt;</span></div><div class="line"><span class="title">SymbolTable</span><span class="params">()</span>                创建ST</div><div class="line"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> 将键值对存入表当中</div><div class="line">Value <span class="title">get</span><span class="params">(Key key)</span>           根据Key查找value</div><div class="line"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>         从表当中删除key</div><div class="line"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span>    键值key在表当中是否存在对应值</div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>            判断表是否为空</div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                   判断表的容量</div><div class="line">Iterable&lt;key&gt; <span class="title">keys</span><span class="params">()</span>         表当中所有键值对的集合</div></pre></td></tr></table></figure>
<h3 id="基于无序链表的顺序查找"><a href="#基于无序链表的顺序查找" class="headerlink" title="基于无序链表的顺序查找"></a>基于无序链表的顺序查找</h3><blockquote>
<p>将链表应用于符号表是通过每个节点存储<code>key-value</code>对，同时通过<code>get()</code>方法遍历链表，当被查找的<code>key</code>和结点所对应的<code>key</code>完全一致时，则返回对应结点的数值，否则返回<code>null</code>。<code>put()</code>方法的实现同样是通过遍历链表，当被查找的<code>key</code>和结点当中存储的完全一致是，则将第二个参数<code>value</code>的值更新结点位置的数值。</p>
</blockquote>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/sequential-search.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;</div><div class="line">    privagte <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Key key;</div><div class="line">        Value value;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function">publci <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">        <span class="comment">//查找部分，根据给定的key，查找对应value，不存在返回null</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                <span class="keyword">return</span> x.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">        <span class="comment">//插入部分，根据给定的key，如果找到，更新其value，未找到则new出新的结点</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                x.value = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        first = <span class="keyword">new</span> Node(key, value, first);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于有序数组的二分查找"><a href="#基于有序数组的二分查找" class="headerlink" title="基于有序数组的二分查找"></a>基于有序数组的二分查找</h3><blockquote>
<p>通过应用一对平行数组，利用其中一个存储<code>key</code>一个存储<code>value</code>，从而实现高效的索引以及其他操作。<br>这部分的核心是实现<code>rank()</code>方法，该方法可以返回<code>table</code>当中小于给定<code>value</code>的数量，对于<code>get()</code>方法，当给定的<code>key</code>存在于表当中的时候，<code>rank()</code>方法便能够通知该<code>key</code>的位置。对于<code>put()</code>方法，<code>rank</code>方法可以确定<code>value</code>的更新位置。</p>
</blockquote>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/binary-search.png" alt="enter image description here"></p>
<p>二分查找算法当中存在一个<code>rank()</code>函数，用于返回查询键值的位置，当表中存在该键的时候，返回值表示<code>table</code>当中小于他的键的数量。如果表当中不存在改键，<code>rank()</code>同样返回表当中小于它的键的数目。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty()) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">    <span class="keyword">int</span> i = rank(key);<span class="comment">//找到key在数组中对应的位置</span></div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; key[i] == key) &#123;</div><div class="line">        <span class="keyword">return</span> values[i];</div><div class="line">        <span class="comment">//N为数组大小，如果key和数组当中对应位置的i匹配，返回其对应值</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = rank(key);</div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i] == key) &#123;</div><div class="line">        values[i] = value;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建新元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j-- ) &#123;</div><div class="line">        keys[j] = keys[j-<span class="number">1</span>];</div><div class="line">        values[j] = values[j-<span class="number">1</span>];</div><div class="line">    &#125;<span class="comment">//用于对位置i进行置空,将大于i的元素向后移动</span></div><div class="line">    keys[i] = key;</div><div class="line">    values[i] = value;</div><div class="line">    N++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt; low) &#123; <span class="keyword">return</span> low;&#125;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">    <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, low, mid-<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, mid+<span class="number">1</span>, high);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">&#125;</div><div class="line"><span class="comment">//迭代</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = N-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>( low &lt;= high)&#123;</div><div class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">        <span class="keyword">if</span> (compare &lt; <span class="number">0</span>) <span class="keyword">return</span> high = mid - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> low = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Binary-Search-Tree-二叉查找树"><a href="#Binary-Search-Tree-二叉查找树" class="headerlink" title="Binary Search Tree (二叉查找树)"></a>Binary Search Tree (二叉查找树)</h2><blockquote>
<p>以上提到的链表的顺序查找以及二分查找均不能同时在查找和插入两个方面很好的完成工作。 二叉树的数据结构能很好的兼顾这两方面。二叉树查找的每个节点均包含两个值，分别为键以及相关联的数值。同时二叉树的左子节点的数值也小于右子节点的数值。</p>
</blockquote>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320221749.jpg" alt="enter image description here"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>当二叉树为空时，查找对应未命中；当被查找的键和根结点的键对应的时候，即为查找命中。否则便递归地在子树当中进行查找，如果被查找的键比较小，选择左子树，否则便选择右子树。</p>
<p><div align="center"><br><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1fayquslvw0j30f20avjte.jpg" alt=""></div></p>
<div>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当查找一个不存在于树当中的节点并且查找结束于一条空链接的时候，需要将链接指向一个含有被查找的键的新结点的位置。简而言之，当树为空，但会含有被查找键值对的新节点；当被查找的键小于根节点的键时，在左子树插入，否则在右子树插入。</p>
<p><div align="center"><br><img src="http://algs4.cs.princeton.edu/32bst/images/bst-insert.png" alt=""></div></p>
<div>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>Binary Search的算法的查找和插入运行时间在平均情况下都可以达到O(logn)。当时这个时间复杂度在很大程度上会受到树的形状的影响，同时树的形状又取决于键值被插入的先后顺序。</p>
<p>最好的情况系啊，一棵含有N个结点的树是完全平衡的，每条空连接到其根结点的距离都为logN。但是在最坏的情况下，搜索的路径上可能含有N个节点</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320222706.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySerach</span></span>&#123;</div><div class="line">    to be update</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Balanced-Search-Tree-平衡查找树"><a href="#Balanced-Search-Tree-平衡查找树" class="headerlink" title="Balanced Search Tree (平衡查找树)"></a>Balanced Search Tree (平衡查找树)</h2><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><blockquote>
<p>前面提到的几个搜索算法在最坏的情况下的性能依然不能令人满意。因此非常需要一个算法能够在查找和插入过程中都能保证很好的性能。这部分介绍的平衡搜索树能很好的解决这个问题。</p>
<p>在理想情况下，平衡查找树都能保证运行时间是对数级别的。对于一个含有N个节点的树当中，树的高度可以保证为lgN。这样便可以保证查找可以在lgN次内结束。</p>
</blockquote>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li><p>2-3树当中的2结点，含有一个<code>key</code>以及两条链接，左链接对应的<code>key</code>都小于父结点，右链接对应的<code>key</code>都大于父结点。</p>
</li>
<li><p>2-3树当中的3结点，含有两个<code>key</code>以及三条链接，左链接<br>对应的<code>key</code>都大于该结点，右链接对应的<code>key</code>都小于该结点，，中间链接对应的结点处于该结点两个<code>key</code>的中间。</p>
</li>
</ol>
<p><div align="center"><br><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320225636.jpg" alt=""></div></p>
<div>

<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>判断<code>key</code>是否在2-3树当中，先将<code>key</code>和结点的<code>key</code>进行比较，如果相等则查找成功。如果未找到，则继续根据情况在子链接当中递归的进行查找。如果最终为空连接，查找未命中。</p>
<p><div align="center"><br><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-search.png" alt=""></div></p>
<div>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><ul>
<li><p>向2-结点当中插入新键</p>
<p>  当插入操作结束于一个2-结点的时候，直接将2-结点替换为一个3-结点，便可以让树继续保持平衡。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png" alt=""></p>
</li>
<li><p>向只含有3-结点的树插入新键</p>
<p>  当一棵树当中只含有3-结点的时候，先临时将新键存入当前结点，构成一个4-结点。在这个情况下，很容易将其转化为一棵由3个2-结点组成的2-3树。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png" alt=""></p>
</li>
<li><p>向父结点为2-结点的3-结点插入新键</p>
<p>  对于此种情况，可以先构造一个4-结点，下一步操作并不是为中键创建新结点，而是将中键上移到父结点的位置，这样便使得空连接到达根节点的距离依然是相同的</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png" alt=""></p>
<p>  类似的对于父结点为3-结点的三结点插入的时候，需要将中键不断上移，直至父节点不需要继续分解。</p>
</li>
</ul>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><h4 id="待更。。。。。。"><a href="#待更。。。。。。" class="headerlink" title="待更。。。。。。"></a>待更。。。。。。</h4><h2 id="Hash-Table-哈希表"><a href="#Hash-Table-哈希表" class="headerlink" title="Hash Table (哈希表)"></a>Hash Table (哈希表)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>散列表是通过数组实现一个无序的符号表，通过<code>key</code>作为数组的索引，数组中键<code>i</code>处对应的存储的是它的对应值，这种方式就可以快速访问任意键的值。</p>
<p>散列查找算法步骤：通过散列函数将被查找的键转化为数组的一个索引(理想情况是每个键对应一个索引，实际情况是会出现多个键值对应同一个索引) -&gt; 处理碰撞冲突(应用拉链法和线性探测法)</p>
</blockquote>
<h3 id="基于拉链法的哈希表"><a href="#基于拉链法的哈希表" class="headerlink" title="基于拉链法的哈希表"></a>基于拉链法的哈希表</h3><p>在查找的<code>key</code>经过Hash函数转化为数组的索引之后，便需要处理这样的一个情况，即某些<code>key</code>在经过Hash函数转化之后会出现相同的索引值，这时候就需要进行–碰撞处理。</p>
<p>一种方法是将大小为M的数组并将其中的每个元素都指向一条链表，对应链表当中的每个结点都存储了该处元素对应的散列值所包含的键值对，这个方法被成为拉链法。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328161219.jpg" alt=""></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>通过<code>key</code>计算对应的Hashcode</li>
<li>根据Hashcode定位到数组中的某个位置array<a href="该位置对应一条链表">Hashcode</a></li>
<li>若链表为空，直接插入，否则进行add操作</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChaingingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">//key-value总数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;  <span class="comment">//HashTable的大小</span></div><div class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st; <span class="comment">// 存放链表对象的数组</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChaingingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</div><div class="line">        <span class="comment">//创建M条链表</span></div><div class="line">        <span class="keyword">this</span>.M = M;</div><div class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</div><div class="line">            st[i] = <span class="function">ne <span class="title">SequentialSearchST</span><span class="params">()</span></span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> (Value) st[hash(key)].get(key);&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;st[hash(key)].put(key, value);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于线性探测法的哈希表"><a href="#基于线性探测法的哈希表" class="headerlink" title="基于线性探测法的哈希表"></a>基于线性探测法的哈希表</h3><p>实现HashTable的另一种方式是通过大小为M的数组保存N的<code>key-value</code>对，其中 M &gt; N; 在这个方法当中是通过数组空位来解决冲突碰撞的问题。</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/linear-probing.png" alt=""></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>在发生碰撞的时候，即一个键的散列值被另一个不同的键占用，此时直接检查散列表当中的下一个位置(对索引值+1)，对应三种结果</p>
<ol>
<li>命中，该位置的键即被查找的键的位置</li>
<li>未命中，键为空</li>
<li>继续查找，该位置的键和被查找的键不同</li>
</ol>
<p>关于线性检测，在查看参考资料的时候看到一个很形象的比喻，我们可以把线性检测操作看作是一次停车，当当前车位已经停车之后，则继续向前直到找到可放入的车位。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg" alt=""></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">//符号表中键值对总数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>; <span class="comment">//线性探测表的大小</span></div><div class="line">    <span class="keyword">private</span> Key[] keys;</div><div class="line">    <span class="keyword">private</span> Value[] values;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</div><div class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</div><div class="line">        values = (Value[]) <span class="keyword">new</span> Object[M];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;&#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (N &gt;= M/<span class="number">2</span>) resize(<span class="number">2</span>*M);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M ) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                values[i] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        keys[i] = key;</div><div class="line">        values[i] = value;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M ) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> values[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>一般的，在应用查找算法的时候，散列表的性能会比红黑树性能好很多，但是这也和 Hash Function的计算效率相关联。但是对于散列表来说，它并不能保证顺序，因此对于顺序操作还是应该采用树结构。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328190932.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">Princeton-Algorithm 4th, Searching Algorithm</a></p>
</div></div></div></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-19</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Data-Structure/" title="Data Structure" class="tag">Data Structure </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://woofww.github.io/2016/12/19/Algorithm-Searching/,EmptyNode,Algorithm-Searching,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/12/22/Design Pattern-Singleton/" title="Design Pattern-Singleton Pattern" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/12/07/Algorithm-Advanced-Sorting/" title="Algorithm-Advanced Sorting" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>