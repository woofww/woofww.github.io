<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Algorithm-MST, Shortest Path · EmptyNode</title><meta name="description" content="最小生成树加权图
在直接讨论最小生成树之前，首先介绍加权图这个概念，这是一种每条边关联一个权值的基于图的模型，在实际生活中有很多加权图的应用，比如地图当中的路径长度。


MST 概念
生成树表示的是一棵含有图中所有顶点的一个无环连通子图，而最小生成树又称最小权重生成树是加权图当中一棵权值和最小的生"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">EmptyNode</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Algorithm-MST, Shortest Path</a></h3></div><div class="post-content"><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h3><blockquote>
<p>在直接讨论最小生成树之前，首先介绍加权图这个概念，这是一种每条边关联一个权值的基于图的模型，在实际生活中有很多加权图的应用，比如地图当中的路径长度。</p>
</blockquote>
<a id="more"></a>
<h3 id="MST-概念"><a href="#MST-概念" class="headerlink" title="MST 概念"></a>MST 概念</h3><blockquote>
<p>生成树表示的是一棵含有图中所有顶点的一个无环连通子图，而最小生成树又称<strong>最小权重生成树</strong>是加权图当中一棵权值和最小的生成树。</p>
</blockquote>
<h2 id="MST算法"><a href="#MST算法" class="headerlink" title="MST算法"></a>MST算法</h2><ul>
<li>关于最小生成树相关算法，其中大多数都是属于贪心算法，通过使用切分定理查找最小生成树当中的一条边，同时不断重复直到找到生成树当中的所有边。</li>
<li>切分定理就是将加权图分为两个集合，检查跨过这两个集合的所有边，然后找出哪条边属于最小生成树。<em>下图中展示了一幅权重图，红色的线表示的是横切边，加粗的红线则表示连接同一个顶点当中权重最小的一条</em></li>
</ul>
<div align="center"><br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fbiatgcj12j30dw08eaah.jpg" alt=""><br></div>

<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>初始状态所有变均为灰色</li>
<li>找出一种切分方式，它的横切边均不为红色</li>
<li>反复操作知道标记V-1条红色边为止</li>
</ul>
<h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><blockquote>
<p>Kruskal最小生成树算法属于一种比较易于理解的生成树算法，它的主要理念是基于对各条边的权重排序</p>
</blockquote>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>将图G当中的各条边的权重值进行排序</li>
<li>取出排序当中权值最小的一条边</li>
<li>如果从队列当中取出的这条边的结点不在同一个联通分量当中，则将这条边添加到图当中</li>
<li>重复上述步骤</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</div><div class="line">        MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;(G.edges());</div><div class="line"></div><div class="line">        UF uf = <span class="keyword">new</span> UF(G.V());</div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty()&amp;&amp;mst.size() &lt; G.V()-<span class="number">1</span>)&#123;</div><div class="line">            Edge e = pq.delMin();</div><div class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v)</div><div class="line">            <span class="keyword">if</span>(!uf.connected(v,w))&#123;</div><div class="line">                uf.union(v,w);</div><div class="line">                mst.enqueue(edge);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="Prim算法的延时实现"><a href="#Prim算法的延时实现" class="headerlink" title="Prim算法的延时实现"></a>Prim算法的延时实现</h5><p>(将失效边保留在优先队列当中，当需要删除他们的时候，再检查其有效性，将删除的步骤延后)</p>
<ul>
<li>起始在图G当中仅包含一个顶点S</li>
<li>使用<strong>优先队列</strong>维护一个和该顶点相连的横切边的集合；顶点索引<strong>数组</strong>来标记树的顶点；一条<strong>队列</strong>保存最小生成树的边</li>
<li>选取所有顶点的横切边当中的最小值加入到最小生成树当中</li>
<li>逐步向树当中添加V-1条边</li>
</ul>
<p><div align="center"><br><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbkr0829luj30jh0bmdhk.jpg" alt=""></div></p>
<div>

<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;   <span class="comment">//最小生成树的顶点</span></div><div class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;    <span class="comment">//最小生成树的边</span></div><div class="line">    <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;     <span class="comment">//横切边(包括失效边)</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</div><div class="line">        pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</div><div class="line"></div><div class="line">        visit(G, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</div><div class="line">            Edge e = pq.delMin(); <span class="comment">//获得权重最小的横切边</span></div><div class="line"></div><div class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);</div><div class="line">            <span class="keyword">if</span> (marked[v]&amp;&amp;marked[w]) &#123;<span class="keyword">continue</span>;<span class="comment">//跳出循环，跳过失效的边&#125;</span></div><div class="line">            mst.enqueue(e); <span class="comment">//否则将边加入到最小生成树</span></div><div class="line">            <span class="keyword">if</span>(!marked[v]) visit(G, v);</div><div class="line">            <span class="keyword">if</span>(!marked[w]) visit(G, w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(Edge e : G.adj(v))&#123;</div><div class="line">            <span class="keyword">if</span> (!marked[e.other(v)]) &#123;</div><div class="line">                pq.insert(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Prim算法的即时实现"><a href="#Prim算法的即时实现" class="headerlink" title="Prim算法的即时实现"></a>Prim算法的即时实现</h5><p>即时Prim算法是将失效边优先从优先队列当中删除，仅保留树顶点和非树顶点之间的横切边</p>
<ul>
<li>起始在图G当中仅包含一个顶点S</li>
<li>使用两个顶点索引数组edgeTo[]和distTo[]来保存非树顶点到树的最短边和该边的权重；将所有这类的顶点都保存在一条索引优先队列当中，索引关联的值是边的权重</li>
</ul>
<p><div align="center"><br><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbks6kss6dj318a0owq93.jpg" alt=""></div></p>
<div>

<h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Edge[] edgeTo; <span class="comment">//距离树最近的边 上图左侧数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo； <span class="comment">//distTo[w] = edgeTo[w].weight 上图右侧数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked; <span class="comment">//如果v在树中则为true</span></div><div class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq; <span class="comment">//有效横切边</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">()</span></span>&#123;</div><div class="line">        edge = <span class="keyword">new</span> Edge[G.V()];</div><div class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY; <span class="comment">//设置初值</span></div><div class="line">        &#125;</div><div class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</div><div class="line"></div><div class="line">        distTo[<span class="number">0</span>] = <span class="number">0.0</span>;</div><div class="line">        pq.insert(<span class="number">0</span>, <span class="number">0.0</span>); <span class="comment">//初始化顶点</span></div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</div><div class="line">            visit(G, pq.delMin); <span class="comment">// 将最近的顶点加入到树当中</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (Edge e : G.adj(v) ) &#123;</div><div class="line">            <span class="comment">//遍历v顶点相邻横切边</span></div><div class="line">            <span class="keyword">int</span> w = e.other(v);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (marked[w]) &#123;<span class="keyword">continue</span>;&#125;</div><div class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w]) &#123;</div><div class="line">                <span class="comment">//最佳边更新为e</span></div><div class="line">                edgeTo[w] = e;</div><div class="line"></div><div class="line">                distTo[w] =e.weight();</div><div class="line">                <span class="keyword">if</span> (pq.contains(w)) &#123;pq.change(w, distTo[w]);&#125;</div><div class="line">                <span class="keyword">else</span> &#123;pq.insert(w, distTo[w]);&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><blockquote>
<p>概念：最短路径简单来说就是描述从图中的一个顶点到达另一个顶点的成本最小的路径。最短路径最常见的应用就是我们在驾驶汽车或者手机当中使用的地图来查询目的地的路径，就应用了最短路径的原理</p>
<p>性质：路径一定是有向的；权重不一定和距离等价；并不是所有的顶点都是可选的；负权重会使得问题更复杂；最短路径一般都是简单的；最短路径不一定是唯一的；可能存在平行边和自环；</p>
</blockquote>
<h3 id="最短路径的数据结构"><a href="#最短路径的数据结构" class="headerlink" title="最短路径的数据结构"></a>最短路径的数据结构</h3><ul>
<li><p>最短路径树中的边：使用一个由顶点索引的有向边对象的edgeTo数组，比如edgeTo[v]表示的是v和它的父节点的边，也是起点到顶点v的最短路径上的最后一条边；</p>
</li>
<li><p>到达起点的距离；由顶点索引的数组distTo[v]，起点到v的最短路径的长度；</p>
</li>
</ul>
<h4 id="边的松弛"><a href="#边的松弛" class="headerlink" title="边的松弛"></a>边的松弛</h4><p>如果假设边v-&gt;w检测从s-&gt;w的最短路径是否是先从s-&gt;v,v-&gt;w; 如果是则更新这条边；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> v = e.from(), w = e.to();</div><div class="line">    <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</div><div class="line">        distTo[w] = distTo[v] + e.weight();</div><div class="line">        edgeTo[w] = e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><blockquote>
<p>Dijkstra算法在计算最短路径的时候和最小生成树的Prim算法比较类似，首先将起点distTo[s]初始化为0，distTo[]的其他元素设置为正无穷，最后将distTo[]最小的非树顶点放松并加入到树当中；</p>
<p>Dijkstra算法的数据结构除了edgeTo和distTo之外，还需要加入一条索引优先队列，用来保存需要被放松的顶点并确认下一个将要被放松的顶点。</p>
</blockquote>
<h4 id="步骤-参考图列链接"><a href="#步骤-参考图列链接" class="headerlink" title="步骤 (参考图列链接)"></a>步骤 <a href="http://algs4.cs.princeton.edu/lectures/44DemoDijkstra.pdf" target="_blank" rel="external"><strong>(参考图列链接)</strong></a></h4><ul>
<li>选择起点，并初始化所有的distTo为无穷大</li>
<li>将顶点的邻接点加入优先队列</li>
<li>将加入队列的点出队，并将对应的边进行放松</li>
<li>继续像优先队列中加入其他顶点</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</div><div class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</div><div class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</div><div class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY; <span class="comment">//初始化</span></div><div class="line">        &#125;</div><div class="line">        distTo[s] = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">        pq.insert(s, <span class="number">0.0</span>); <span class="comment">//优先队列当中插入顶点</span></div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</div><div class="line">            relax(G, pq.delMin());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;</div><div class="line">            <span class="keyword">int</span> w = e.to();</div><div class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</div><div class="line">                distTo[w] = distTo[v] + e.weight();</div><div class="line">                edgeTo[w] = e;</div><div class="line">                <span class="keyword">if</span> (pq.contains(w)) &#123;</div><div class="line">                    pq.change(w, distTo[w]);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    pq.insert(w, distTo[w]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="为什么不能存在负权值？"><a href="#为什么不能存在负权值？" class="headerlink" title="为什么不能存在负权值？"></a><font color="#BF2F34" size="4px">为什么不能存在负权值？</font></h5><p>如果存在负权值便会导致在顶点放松过程当中，使得不等式一直成立，顶点w便会不断进入队列</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/43mst/" target="_blank" rel="external">Princeton-Algorithm 4th, Minimum Spanning Trees</a></p>
<p><a href="http://algs4.cs.princeton.edu/44sp/" target="_blank" rel="external">Princeton-Algorithm 4th, Shortest Paths</a></p>
</div></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-01-05</span><i class="fa fa-tag"></i><a href="/categories/Technique/" title="Technique" class="tag">Technique </a><a href="/tags/Data-Structure/" title="Data Structure" class="tag">Data Structure </a><a href="/tags/Algorithm/" title="Algorithm" class="tag">Algorithm </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,https://woofww.github.io/2017/01/05/Algorithm-MST-Shortest-Path/,EmptyNode,Algorithm-MST, Shortest Path,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/01/16/Java-Programming-Multithreading/" title="Java Programming-Multithreading(Episode 1)" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/12/31/Design-Pattern-Adapter-Pattern/" title="Design Pattern-Adapter Pattern" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>