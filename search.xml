<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Algorithm-MST, Shortest Path]]></title>
      <url>https://woofww.github.io/2017/01/05/Algorithm-MST-Shortest-Path/</url>
      <content type="html"><![CDATA[<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h3><blockquote>
<p>在直接讨论最小生成树之前，首先介绍加权图这个概念，这是一种每条边关联一个权值的基于图的模型，在实际生活中有很多加权图的应用，比如地图当中的路径长度。</p>
</blockquote>
<a id="more"></a>
<h3 id="MST-概念"><a href="#MST-概念" class="headerlink" title="MST 概念"></a>MST 概念</h3><blockquote>
<p>生成树表示的是一棵含有图中所有顶点的一个无环连通子图，而最小生成树又称<strong>最小权重生成树</strong>是加权图当中一棵权值和最小的生成树。</p>
</blockquote>
<h2 id="MST算法"><a href="#MST算法" class="headerlink" title="MST算法"></a>MST算法</h2><ul>
<li>关于最小生成树相关算法，其中大多数都是属于贪心算法，通过使用切分定理查找最小生成树当中的一条边，同时不断重复直到找到生成树当中的所有边。</li>
<li>切分定理就是将加权图分为两个集合，检查跨过这两个集合的所有边，然后找出哪条边属于最小生成树。<em>下图中展示了一幅权重图，红色的线表示的是横切边，加粗的红线则表示连接同一个顶点当中权重最小的一条</em></li>
</ul>
<div align="center"><br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fbiatgcj12j30dw08eaah.jpg" alt=""><br></div>

<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>初始状态所有变均为灰色</li>
<li>找出一种切分方式，它的横切边均不为红色</li>
<li>反复操作知道标记V-1条红色边为止</li>
</ul>
<h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><blockquote>
<p>Kruskal最小生成树算法属于一种比较易于理解的生成树算法，它的主要理念是基于对各条边的权重排序</p>
</blockquote>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>将图G当中的各条边的权重值进行排序</li>
<li>取出排序当中权值最小的一条边</li>
<li>如果从队列当中取出的这条边的结点不在同一个联通分量当中，则将这条边添加到图当中</li>
<li>重复上述步骤</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</div><div class="line">        MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;(G.edges());</div><div class="line"></div><div class="line">        UF uf = <span class="keyword">new</span> UF(G.V());</div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty()&amp;&amp;mst.size() &lt; G.V()-<span class="number">1</span>)&#123;</div><div class="line">            Edge e = pq.delMin();</div><div class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v)</div><div class="line">            <span class="keyword">if</span>(!uf.connected(v,w))&#123;</div><div class="line">                uf.union(v,w);</div><div class="line">                mst.enqueue(edge);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h3><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><h5 id="Prim算法的延时实现"><a href="#Prim算法的延时实现" class="headerlink" title="Prim算法的延时实现"></a>Prim算法的延时实现</h5><p>(将失效边保留在优先队列当中，当需要删除他们的时候，再检查其有效性，将删除的步骤延后)</p>
<ul>
<li>起始在图G当中仅包含一个顶点S</li>
<li>使用<strong>优先队列</strong>维护一个和该顶点相连的横切边的集合；顶点索引<strong>数组</strong>来标记树的顶点；一条<strong>队列</strong>保存最小生成树的边</li>
<li>选取所有顶点的横切边当中的最小值加入到最小生成树当中</li>
<li>逐步向树当中添加V-1条边</li>
</ul>
<p><div align="center"><br><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbkr0829luj30jh0bmdhk.jpg" alt=""></div></p>
<div>

<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;   <span class="comment">//最小生成树的顶点</span></div><div class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;    <span class="comment">//最小生成树的边</span></div><div class="line">    <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;     <span class="comment">//横切边(包括失效边)</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</div><div class="line">        pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</div><div class="line"></div><div class="line">        visit(G, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</div><div class="line">            Edge e = pq.delMin(); <span class="comment">//获得权重最小的横切边</span></div><div class="line"></div><div class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);</div><div class="line">            <span class="keyword">if</span> (marked[v]&amp;&amp;marked[w]) &#123;<span class="keyword">continue</span>;<span class="comment">//跳出循环，跳过失效的边&#125;</span></div><div class="line">            mst.enqueue(e); <span class="comment">//否则将边加入到最小生成树</span></div><div class="line">            <span class="keyword">if</span>(!marked[v]) visit(G, v);</div><div class="line">            <span class="keyword">if</span>(!marked[w]) visit(G, w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(Edge e : G.adj(v))&#123;</div><div class="line">            <span class="keyword">if</span> (!marked[e.other(v)]) &#123;</div><div class="line">                pq.insert(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Prim算法的延时实现-1"><a href="#Prim算法的延时实现-1" class="headerlink" title="Prim算法的延时实现"></a>Prim算法的延时实现</h4><p>即时Prim算法是将失效边优先从优先队列当中删除，仅保留树顶点和非树顶点之间的横切边</p>
<ul>
<li>起始在图G当中仅包含一个顶点S</li>
<li>使用两个顶点索引数组edgeTo[]和distTo[]来保存非树顶点到树的最短边和该边的权重；将所有这类的顶点都保存在一条索引优先队列当中，索引关联的值是边的权重</li>
</ul>
<p><div align="center"><br><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbks6kss6dj318a0owq93.jpg" alt=""></div></p>
<div>

<h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Edge[] edgeTo; <span class="comment">//距离树最近的边 上图左侧数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo； <span class="comment">//distTo[w] = edgeTo[w].weight 上图右侧数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked; <span class="comment">//如果v在树中则为true</span></div><div class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq; <span class="comment">//有效横切边</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">()</span></span>&#123;</div><div class="line">        edge = <span class="keyword">new</span> Edge[G.V()];</div><div class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</div><div class="line">            distTo[v] = Double.POSITIVE_INFINITY; <span class="comment">//设置初值</span></div><div class="line">        &#125;</div><div class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</div><div class="line"></div><div class="line">        distTo[<span class="number">0</span>] = <span class="number">0.0</span>;</div><div class="line">        pq.insert(<span class="number">0</span>, <span class="number">0.0</span>); <span class="comment">//初始化顶点</span></div><div class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</div><div class="line">            visit(G, pq.delMin); <span class="comment">// 将最近的顶点加入到树当中</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (Edge e : G.adj(v) ) &#123;</div><div class="line">            <span class="comment">//遍历v顶点相邻横切边</span></div><div class="line">            <span class="keyword">int</span> w = e.other(v);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (marked[w]) &#123;<span class="keyword">continue</span>;&#125;</div><div class="line">            <span class="keyword">if</span> (e.weitht() &lt; distTo[w]) &#123;</div><div class="line">                <span class="comment">//最佳边更新为e</span></div><div class="line">                edgeTo[w] = e;</div><div class="line"></div><div class="line">                distTo[w] =e.weitht();</div><div class="line">                <span class="keyword">if</span> (pq.contains(w)) &#123;pq.change(w, distTo[w]);&#125;</div><div class="line">                <span class="keyword">else</span> &#123;pq.insert(w, distTo[w]);&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Design Pattern-Adapter Pattern]]></title>
      <url>https://woofww.github.io/2016/12/31/Design-Pattern-Adapter-Pattern/</url>
      <content type="html"><![CDATA[<h2 id="产生动机"><a href="#产生动机" class="headerlink" title="产生动机"></a>产生动机</h2><ul>
<li>在软件开发当中，适配器模式(Adapter Pattern)正如其名，非常类似于我们生活当中的电源适配器(可将交流电压转化为正常工作电压)</li>
<li>在实际的编程当中，Client一般可以通过目标类的接口访问它提供的各种服务，有的时候现有的类能够满足客户对某个功能的要求，但是它提供的接口并不是客户所期望的，原因可能因为是现有类当中的方法名和目标类当中定义的方法名不一致所导致的。</li>
</ul>
<a id="more"></a>
<ul>
<li>在出现上述情况的时候，我们就需要将现有的接口转化为客户所期望的接口，通过这种方式便可以保证对现有类的重用，如果不进行这种操作，Client就无法使用现有类所提供的功能，这时候适配器就可以实现这个作用。</li>
<li>在适配器模式当中可以定义一个Wrapper类，将不兼容接口的对象进行包装，Wrapper类指代的就是Adapter，它包装的对象就是适配者(Adaptee)。</li>
<li>适配器向Client提供需要的接口，它实现的就是把Client的请求转化为对适配者(Adaptee)对应接口的调用，客户类并不会直接访问适配者类，而是通过适配器使得由于接口不兼容而不能相互工作的类一起工作。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="Adapter-Pattern-结构"><a href="#Adapter-Pattern-结构" class="headerlink" title="Adapter Pattern 结构"></a>Adapter Pattern 结构</h3><ul>
<li>Target: 目标抽象类</li>
<li>Adapter: 适配器类</li>
<li>Adaptee: 适配者类</li>
<li>Client: 客户类(可以对应为main)</li>
</ul>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>类适配器</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fbfnrc2mqwj30h8081aai.jpg" alt=""></p>
<p>对象适配器</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fbfnrtyln7j30hp095gm7.jpg" alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*类适配器模式</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oriOperation</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="comment">//目标类的接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oriOperation</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//适配者不存在方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newOperation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newOperation</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*对象适配器模式</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="comment">//目标类的接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oriOperation</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//适配者不存在方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newOperation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oriOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee.oriOperation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//相关逻辑代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><ul>
<li>对于上述两种适配器模式，在实际应用当中该如何进行区分呢？<ul>
<li>类适配器应用的方式是通过对象的继承方式；对象适配器是通过对象组合方式，属于一种动态方式</li>
<li>在类适配器中，Adapter是直接继承自Adaptee的，不能够再和Adaptee的子类进行协作，继承是一种静态的关系，在继承了Adaptee之后，就无法再去处理Adaptee子类了；在对象适配器当中，一个Adapter可以将多个Adaptee集成到同一个Target当中，一个Adapter能够将Adaptee类以及它的子类都应用到Target接口处，这样处理更为灵活一些</li>
<li>类适配器可以重定义Adaptee的行为，对父类方法进行Override; 对象适配器在重定义Adaptee的行为的时候比较麻烦，对于对象适配器最好就是通过定义Adaptee的一个子类实现对Adapter的重写，然后适配器对子类进行适配，最终应用到Target</li>
</ul>
</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p>优点</p>
<ol>
<li>当系统的现有类的接口不能满足需要的时候，可以通过适配器模式使得功能进行更好的复用</li>
<li>在实现适配器功能的过程中，同样可以对自己需要的功能进行调用，对系统进行了扩展</li>
</ol>
</li>
<li><p>缺点</p>
<p>  当系统过多地使用了适配器的时候，会让系统的结构比较混乱</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Graph]]></title>
      <url>https://woofww.github.io/2016/12/30/Algorithm-Graph/</url>
      <content type="html"><![CDATA[<h2 id="Graph-图"><a href="#Graph-图" class="headerlink" title="Graph (图)"></a>Graph (图)</h2><blockquote>
<p>简单来说，图 G(V,E)是由一组顶点(Vertex)和一组能够将两个顶点相连的边(Edge)组成的。同时根据边是否有向还可以把图分为有向图和无向图。当对图中的边赋予某些数值的时候(比如每条边对应的路径长度)，这时候又可以分为有权重和无权重图。</p>
</blockquote>
<a id="more"></a>
<h3 id="图相关概念"><a href="#图相关概念" class="headerlink" title="图相关概念"></a>图相关概念</h3><ul>
<li>Vertex: 图当中用于连接的基本元素</li>
<li>Edge: 将顶点相连接的线</li>
<li>Path: 由图中的一个顶点到达另一个顶点所经过的边</li>
<li>Cycle: 由图当中的一个顶点经过一系列路径最终返回该顶点，这条路径被称为环(Cycle)</li>
<li>Degree: 顶点的度表示的是和该顶点相连接的边的数目，在有向图当中又被分为出度和入度</li>
<li>Connected Component: 所有相互连接的顶点和边构成了Connected Component，在一张图中可能会含有多个CC</li>
<li>Connectivity: 在图论当中，如果图当中的任意的一个顶点都存在一条到达另一个顶点的路径，这是就称这幅图的连通的。例：树就是一种无环连通图</li>
</ul>
<div align="center"><br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fbegimu9cqj30fh09g0td.jpg" alt=""><br></div>

<h3 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul>
<li>使用一个V*V的布尔矩阵来表示图，当定点v和w之间存在连接的时候，将v行w列的元素设置为true</li>
</ul>
<div align="center"><br><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fbekrvm5lbj30ic09g404.jpg" alt=""><br></div>

<h4 id="邻接表数组"><a href="#邻接表数组" class="headerlink" title="邻接表数组"></a>邻接表数组</h4><ul>
<li>可以利用图的顶点作为一个索引列表数组，其中的每一个元素都是和该索引顶点相邻的顶点的列表</li>
</ul>
<div align="center"><br><img src="http://algs4.cs.princeton.edu/41graph/images/adjacency-lists.png" alt=""><br></div>


<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="Undirected-Graph"><a href="#Undirected-Graph" class="headerlink" title="Undirected Graph"></a>Undirected Graph</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无向图的数据类型</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</div><div class="line">Graph(<span class="keyword">int</span> V)                 创建一个含有V个顶点但是不含有边的图</div><div class="line">Graph(In in)                 通过标准输入流in读入一幅图</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span>                      顶点数</span></div><div class="line"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span>                      边数</div><div class="line"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span>   在顶点v w之间添加一条边</div><div class="line">Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> 和顶点v相邻的顶点</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS (深度优先遍历)"></a>DFS (深度优先遍历)</h4><p>DFS用一句俗话来形容可以称为<strong>不撞南墙不回头</strong>，基于图的深度遍历是通过不断地对顶点的邻接表进行递归运算，当邻接表的点未被标记的时候，则继续进行DFS。当该点被标记的时候，则查询其他位，在所有邻接表中的所有顶点都完成查询的时候，向上返回。</p>
<ul>
<li>数据结构<ol>
<li>用marked[]布尔数组标记访问过的顶点</li>
<li>用edgeTo[]整型数组保存经过的路径</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span></span>&#123;</div><div class="line">    <span class="comment">//数组存储结构</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">        <span class="comment">//数据结构的初始化</span></div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">        dfs(G,s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : G.adj(v))&#123;</div><div class="line">            <span class="keyword">if</span>(!marked[w])&#123;</div><div class="line">                edgeTo[w] = v;</div><div class="line">                dfs(G,w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS (广度优先遍历)"></a>BFS (广度优先遍历)</h4><p>相对于DFSl的<strong>一条路走到黑</strong>，BSF更像是<strong>多路分身齐头并进</strong>，BFS可以用于最短路径的搜索，如果要找到某两点之间的最短距离，需要从起始点开始，在所有经过一条边即可到达的点当中寻找目标点，如果找不多继续扩大，知道最终成功找到目标点。</p>
<ul>
<li><p>数据结构</p>
<p>  除了和DFS中一致的数据结构之外，BFS还显式的使用了队列，来按照起点的顺序遍历所有顶点(比如首先将起始点加入队列，随后在队列中移除起始点，将于起始点相连的边长为1的顶点加入队列，以此类推)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstSearch</span></span>&#123;</div><div class="line">    <span class="comment">//数组存储结构</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span></span>&#123;</div><div class="line">        <span class="comment">//数据结构的初始化</span></div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">        dfs(G,s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue();</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        queue.enqueue(s);</div><div class="line">        <span class="keyword">while</span>(!queue,isEmpty())&#123;</div><div class="line">            <span class="keyword">int</span> v = queue.dequeue(); <span class="comment">//从队列中删去下一顶点</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w : G.adj(v))&#123;</div><div class="line">                <span class="keyword">if</span>(!marked[w])&#123;</div><div class="line">                    edgeTo[w] = v;</div><div class="line">                    marked[w] = <span class="keyword">true</span>;</div><div class="line">                    queue.enqueue(w);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Directed-Graph"><a href="#Directed-Graph" class="headerlink" title="Directed Graph"></a>Directed Graph</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>有向图当中， 边是单向的，每条边所连接的两个顶点是一个有序对，一个顶点称为头另一个顶点被称为尾，它的邻接性也是单向的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有向图的数据类型</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> class Digraph</span></div><div class="line"></div><div class="line"><span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span>                创建一幅含有V个顶点但是没有边的有向图</div><div class="line"><span class="title">Digraph</span><span class="params">(In in)</span>                从输入流in读入一幅有向图</div><div class="line"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span>                       顶点总数</div><div class="line"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span>                       边的总数</div><div class="line"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span>    向图中添加一条边v-&gt;w</div><div class="line">Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span>  由v指出的边所连接的所有顶点</div><div class="line">Digraph <span class="title">reverse</span><span class="params">()</span>             创建图的反向图</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Design Pattern-Factory Pattern]]></title>
      <url>https://woofww.github.io/2016/12/28/Design-Pattern-Factory-Method/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>一种实现了“工厂”概念的面向对象的设计模式。和其他的创建型模式Template Method一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。该模式的实质实际上是”定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。因此工厂方法的作用就是将实例化进程推迟到子类当中进行”。在对象创建过程当中，有些过程包括决定创建哪个对象，管理对象的生命周期，以及管理特定对象的创建以及销毁。<a href="https://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank" rel="external">—Wikipedia</a></p>
</blockquote>
<a id="more"></a>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb7z27kettj30rs0dw3zw.jpg" alt=""></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>简单工厂模式</p>
<p> 简单工厂模式又被称作静态工厂方法(Static Factory Method)模式，这种模式和单例模式都属于一种创建型模式。简单工厂模式根据参数的不同来返回不同的实例，简单工厂模式是专门用来定义一个类来负责创建其他类的实例，一般被创建的实例都继承自相同的父类。</p>
</li>
<li><p>工厂方法模式</p>
<p> 工厂方法模式又被成为虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。该模式当中，工厂父类用于定义创建产品对象的公共接口，对于子类则是负责产生具体的产品对象，这样的目的是将产品类的实例化操作延迟到工厂的子类中完成。</p>
</li>
<li><p>抽象工厂方法</p>
<p> 提供一个创建一系列相关或者相互以来对象的接口，而无需指定他们具体的类</p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//产品A被生产</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//产品B被生产</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductA <span class="title">createA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductB <span class="title">createB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Product a = ProductFactory.createA();</div><div class="line">        a.produce();</div><div class="line">        Product b = ProductFactory.createB();</div><div class="line">        b.produce();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p>优点</p>
<p>  工厂类的创建逻辑比较简单，当需要实例化某个产品对象的时候，直接通过工厂类进行创建即可</p>
</li>
<li><p>缺点</p>
<ol>
<li><p>当系统需要进行扩展的时候，都要向工厂类当中添加创建逻辑，当产品类型较多的时候，工厂类会比较庞大</p>
</li>
<li><p>简单工厂模式使用静态工厂方法，造成工厂角色无法形成基于继承的层次结构</p>
</li>
</ol>
</li>
</ul>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//产品A被生产</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//产品B被生产</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">produce</span><span class="params">(String product)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (product.equals(<span class="string">"ProductA"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Product a = ProductFactory.produce(<span class="string">"A"</span>);</div><div class="line">        a.produce();</div><div class="line">        Product b = ProductFactory.produce(<span class="string">"B"</span>);</div><div class="line">        b.produce();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p>优点</p>
<ol>
<li><p>工厂类(ProductFactory类)当中含有必要的逻辑判断，使得可以决定在什么时候创建哪一个产品的实例。简单工厂模式通过这种做法实现了责任的分割，通过工厂类来提供实例的创建，消费者直接调用工厂类即可</p>
</li>
<li><p>客户端无需知道产品类的类名，只要知道产品类对应的参数即可</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>系统扩展较为困难，当需要增加新的产品的时候(比如增加ProductC时候)，工厂类的逻辑则需要进行修改，当产品层次较多的时候，会导致工厂类的逻辑比较复杂。</p>
</li>
<li><p>简单工厂模式使用静态工厂方法，造成工厂角色无法形成基于继承的层次结构</p>
</li>
</ol>
</li>
</ul>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><blockquote>
<p>抽象工厂模式形象地说可以是围绕一个超级工厂创建其他的工厂，即由一个SuperFactory创建一系列ChildFactory</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 抽象工厂的部分的层级比较复杂，抽象工厂类 -&gt; 具体工厂类 -&gt; 具体产品</div><div class="line">* 这部分使用具体的例子来表示抽象工厂方法</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</div><div class="line">    <span class="comment">// 产品接口</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//实现具体产品具体方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//同上</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--------- 分隔符 ---------</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</div><div class="line">    <span class="comment">//另一个产品接口</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//实现产品方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//同上</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--------- 分隔符 ---------</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</div><div class="line">    <span class="comment">//通过抽象工厂获取产品实例</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//产品工厂类</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (shape == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (shape.equals(<span class="string">"Square"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">"Circle"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果无法匹配返回null</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (color == <span class="string">"Red"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (color == <span class="string">"Blue"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Blue();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> shape <span class="title">getShape</span><span class="params">(String shape)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--------- 分隔符 ---------</div><div class="line"><span class="comment">//产生特定工厂</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(choice.equals(<span class="string">"shape"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equals(<span class="string">"color"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">--------- 分隔符 ---------</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</div><div class="line">         AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</div><div class="line">         <span class="comment">//同理可以通过每个factory获取特定实例</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Design Pattern-Singleton Pattern]]></title>
      <url>https://woofww.github.io/2016/12/22/Design%20Pattern-Singleton/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在软件工程当中，设计模式 (Design Pattern) 是对软件设计当中普遍存在的各种问题，所得出的解决方案。设计模式并不是直接用来完成代码的编写，而是描述在不同的状况下，要如何解决问题的一种方案。</p>
<a id="more"></a>
<p>面向对象设计模式通常以类别或者对象来描述其中的关系和相互作用， 但不涉及用来完成应用程序的特定类别或者对象。设计模式能使不稳定依赖于相对稳定，具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。本系列文章将主要着重于介绍Android开发中几个常用的设计模式进行介绍和探讨。<a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="external">—Wikipedia</a></p>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>在应用单例模式的时候，单例对象的类必须保证只有一个实例存在。 在很多情况下，整个系统只需要拥有一个全局对象，这样更有利于对系统整体的行为进行协调。比如在服务器程序当中，该服务器的配置信息存放在一个文件当中，这些服务器的配置便由一个单例对象进行统一的读取，然后服务器中的其他对象在通过这个单例对象进行配置信息的获取，这样便简化了配置管理的环境。</p>
</blockquote>
<ul>
<li><img src="http://s9.sinaimg.cn/mw690/674f4fc6gddd1e4334838&amp;690" alt=""></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p>A:单例模式只能存在一个实例；</p>
<p>B:单例模式类必须自己创建自己的唯一实例；</p>
<p>C:单例模式类必须给其他所有对象提供这个实例</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>懒汉单例模式</p>
<p> 第一次对单例对象进行实例化的时候，当处于并发环境的时候，可能会出现多个单例本身对象，这样就是线程不安全的。</p>
</li>
<li><p>饿汉单例模式</p>
<p> 在单例类进行初始化的时候，已经自行实例化一个静态对象，本身便是线程安全的。</p>
</li>
<li><p>登记单例模式</p>
<p> 通过一个专门的类对各个单例模式的单一实例进行管理和维护</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*这个方式产生的是全局性的实例，在多线程的情况下，存在全局共享的变量是非常危险的，</div><div class="line">*当多个线程都参与调用了getSingleton()的话，都会对判断条件进行执行，</div><div class="line">*这样便会导致多个线程实例被创建出来。</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//阻止外部对象进行实例化</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/*当单例为空的时候进行创建，否则直接返回，保证唯一性*/</span></div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*线程安全的懒汉单例模式*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//阻止外部对象进行实例化</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*Double-Check模式*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//同步各个线程</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//当同步线程当中不存在单例实例的时候，创建新的实例</span></div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*Volatile模式</span></div><div class="line">*由于创建实例的操作并不是原子性的</div><div class="line">*JVM在编译的时候存在指令的重排序优化，很有可能在创建对象实例的时候，优先指定实例的内存空间</div><div class="line">*然而实例并未创建，很可能被其他线程抢占，导致报错</div><div class="line">*解决方式：通过使用volatile限制JVM的重排序</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//同步各个线程</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//当同步线程当中不存在单例实例的时候，创建新的实例</span></div><div class="line">                    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>总结：</p>
<ol>
<li><p>private的构造函数主要目的是为了阻止外部构造类的实例，以防产生多个类的实例</p>
</li>
<li><p>产生类的实例的方式是通过static方式使其形成实例，因为可以在这部分访问private构造函数</p>
</li>
</ol>
</blockquote>
<h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//阻止外部对象进行实例化</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="登记单例模式"><a href="#登记单例模式" class="headerlink" title="登记单例模式"></a>登记单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//用于存储需要管理的实例</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Singleton&gt; map = <span class="keyword">new</span> HashMap&lt;String, Singleton&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//静态创建实例并添加到Map集合当中</span></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        <span class="comment">//通过反射获取单例实例</span></div><div class="line">        map.put(singleton.getClass().getName(), singleton);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//限制实例创建</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> map.get(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Searching]]></title>
      <url>https://woofww.github.io/2016/12/19/Algorithm-Searching/</url>
      <content type="html"><![CDATA[<h2 id="Symbol-Table-符号表"><a href="#Symbol-Table-符号表" class="headerlink" title="Symbol Table (符号表)"></a>Symbol Table (符号表)</h2><blockquote>
<p>定义： 符号表是一种可以存储<code>key-value</code>的数据结构，它可以进行两种操作，<code>put</code>(将键值对存入符号表)和<code>get</code>操作(根据给定的<code>key</code>查找<code>value</code>)，就相当于字典查询一样，需要通过索引进行对应查找</p>
</blockquote>
<a id="more"></a>
<h3 id="Base-API"><a href="#Base-API" class="headerlink" title="Base API"></a>Base API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class SymbolTable&lt;key,value&gt;</span></div><div class="line"><span class="title">SymbolTable</span><span class="params">()</span>                创建ST</div><div class="line"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> 将键值对存入表当中</div><div class="line">Value <span class="title">get</span><span class="params">(Key key)</span>           根据Key查找value</div><div class="line"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>         从表当中删除key</div><div class="line"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span>    键值key在表当中是否存在对应值</div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>            判断表是否为空</div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                   判断表的容量</div><div class="line">Iterable&lt;key&gt; <span class="title">keys</span><span class="params">()</span>         表当中所有键值对的集合</div></pre></td></tr></table></figure>
<h3 id="基于无序链表的顺序查找"><a href="#基于无序链表的顺序查找" class="headerlink" title="基于无序链表的顺序查找"></a>基于无序链表的顺序查找</h3><blockquote>
<p>将链表应用于符号表是通过每个节点存储<code>key-value</code>对，同时通过<code>get()</code>方法遍历链表，当被查找的<code>key</code>和结点所对应的<code>key</code>完全一致时，则返回对应结点的数值，否则返回<code>null</code>。<code>put()</code>方法的实现同样是通过遍历链表，当被查找的<code>key</code>和结点当中存储的完全一致是，则将第二个参数<code>value</code>的值更新结点位置的数值。</p>
</blockquote>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/sequential-search.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;</div><div class="line">    privagte <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Key key;</div><div class="line">        Value value;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function">publci <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">        <span class="comment">//查找部分，根据给定的key，查找对应value，不存在返回null</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                <span class="keyword">return</span> x.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">        <span class="comment">//插入部分，根据给定的key，如果找到，更新其value，未找到则new出新的结点</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                x.value = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        first = <span class="keyword">new</span> Node(key, value, first);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于有序数组的二分查找"><a href="#基于有序数组的二分查找" class="headerlink" title="基于有序数组的二分查找"></a>基于有序数组的二分查找</h3><blockquote>
<p>通过应用一对平行数组，利用其中一个存储<code>key</code>一个存储<code>value</code>，从而实现高效的索引以及其他操作。<br>这部分的核心是实现<code>rank()</code>方法，该方法可以返回<code>table</code>当中小于给定<code>value</code>的数量，对于<code>get()</code>方法，当给定的<code>key</code>存在于表当中的时候，<code>rank()</code>方法便能够通知该<code>key</code>的位置。对于<code>put()</code>方法，<code>rank</code>方法可以确定<code>value</code>的更新位置。</p>
</blockquote>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/binary-search.png" alt="enter image description here"></p>
<p>二分查找算法当中存在一个<code>rank()</code>函数，用于返回查询键值的位置，当表中存在该键的时候，返回值表示<code>table</code>当中小于他的键的数量。如果表当中不存在改键，<code>rank()</code>同样返回表当中小于它的键的数目。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty()) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">    <span class="keyword">int</span> i = rank(key);<span class="comment">//找到key在数组中对应的位置</span></div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; key[i] == key) &#123;</div><div class="line">        <span class="keyword">return</span> values[i];</div><div class="line">        <span class="comment">//N为数组大小，如果key和数组当中对应位置的i匹配，返回其对应值</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = rank(key);</div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i] == key) &#123;</div><div class="line">        values[i] = value;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建新元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j-- ) &#123;</div><div class="line">        keys[j] = keys[j-<span class="number">1</span>];</div><div class="line">        values[j] = values[j-<span class="number">1</span>];</div><div class="line">    &#125;<span class="comment">//用于对位置i进行置空,将大于i的元素向后移动</span></div><div class="line">    keys[i] = key;</div><div class="line">    values[i] = value;</div><div class="line">    N++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt; low) &#123; <span class="keyword">return</span> low;&#125;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">    <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, low, mid-<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, mid+<span class="number">1</span>, high);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">&#125;</div><div class="line"><span class="comment">//迭代</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = N-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>( low &lt;= high)&#123;</div><div class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">        <span class="keyword">if</span> (compare &lt; <span class="number">0</span>) <span class="keyword">return</span> high = mid - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> low = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Binary-Search-Tree-二叉查找树"><a href="#Binary-Search-Tree-二叉查找树" class="headerlink" title="Binary Search Tree (二叉查找树)"></a>Binary Search Tree (二叉查找树)</h2><blockquote>
<p>以上提到的链表的顺序查找以及二分查找均不能同时在查找和插入两个方面很好的完成工作。 二叉树的数据结构能很好的兼顾这两方面。二叉树查找的每个节点均包含两个值，分别为键以及相关联的数值。同时二叉树的左子节点的数值也小于右子节点的数值。</p>
</blockquote>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320221749.jpg" alt="enter image description here"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>当二叉树为空时，查找对应未命中；当被查找的键和根结点的键对应的时候，即为查找命中。否则便递归地在子树当中进行查找，如果被查找的键比较小，选择左子树，否则便选择右子树。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1fayquslvw0j30f20avjte.jpg" alt=""></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当查找一个不存在于树当中的节点并且查找结束于一条空链接的时候，需要将链接指向一个含有被查找的键的新结点的位置。简而言之，当树为空，但会含有被查找键值对的新节点；当被查找的键小于根节点的键时，在左子树插入，否则在右子树插入。</p>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-insert.png" alt=""></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>Binary Search的算法的查找和插入运行时间在平均情况下都可以达到O(logn)。当时这个时间复杂度在很大程度上会受到树的形状的影响，同时树的形状又取决于键值被插入的先后顺序。</p>
<p>最好的情况系啊，一棵含有N个结点的树是完全平衡的，每条空连接到其根结点的距离都为logN。但是在最坏的情况下，搜索的路径上可能含有N个节点</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320222706.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySerach</span></span>&#123;</div><div class="line">    to be update</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Balanced-Search-Tree-平衡查找树"><a href="#Balanced-Search-Tree-平衡查找树" class="headerlink" title="Balanced Search Tree (平衡查找树)"></a>Balanced Search Tree (平衡查找树)</h2><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><blockquote>
<p>前面提到的几个搜索算法在最坏的情况下的性能依然不能令人满意。因此非常需要一个算法能够在查找和插入过程中都能保证很好的性能。这部分介绍的平衡搜索树能很好的解决这个问题。</p>
<p>在理想情况下，平衡查找树都能保证运行时间是对数级别的。对于一个含有N个节点的树当中，树的高度可以保证为lgN。这样便可以保证查找可以在lgN次内结束。</p>
</blockquote>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li><p>2-3树当中的2结点，含有一个<code>key</code>以及两条链接，左链接对应的<code>key</code>都小于父结点，右链接对应的<code>key</code>都大于父结点。</p>
</li>
<li><p>2-3树当中的3结点，含有两个<code>key</code>以及三条链接，左链接<br>对应的<code>key</code>都大于该结点，右链接对应的<code>key</code>都小于该结点，，中间链接对应的结点处于该结点两个<code>key</code>的中间。</p>
</li>
</ol>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320225636.jpg" alt=""></p>
<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>判断<code>key</code>是否在2-3树当中，先将<code>key</code>和结点的<code>key</code>进行比较，如果相等则查找成功。如果未找到，则继续根据情况在子链接当中递归的进行查找。如果最终为空连接，查找未命中。</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-search.png" alt=""></p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><ul>
<li><p>向2-结点当中插入新键</p>
<p>  当插入操作结束于一个2-结点的时候，直接将2-结点替换为一个3-结点，便可以让树继续保持平衡。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png" alt=""></p>
</li>
<li><p>向只含有3-结点的树插入新键</p>
<p>  当一棵树当中只含有3-结点的时候，先临时将新键存入当前结点，构成一个4-结点。在这个情况下，很容易将其转化为一棵由3个2-结点组成的2-3树。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png" alt=""></p>
</li>
<li><p>向父结点为2-结点的3-结点插入新键</p>
<p>  对于此种情况，可以先构造一个4-结点，下一步操作并不是为中键创建新结点，而是将中键上移到父结点的位置，这样便使得空连接到达根节点的距离依然是相同的</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png" alt=""></p>
<p>  类似的对于父结点为3-结点的三结点插入的时候，需要将中键不断上移，直至父节点不需要继续分解。</p>
</li>
</ul>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><h4 id="待更。。。。。。"><a href="#待更。。。。。。" class="headerlink" title="待更。。。。。。"></a>待更。。。。。。</h4><h2 id="Hash-Table-哈希表"><a href="#Hash-Table-哈希表" class="headerlink" title="Hash Table (哈希表)"></a>Hash Table (哈希表)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>散列表是通过数组实现一个无序的符号表，通过<code>key</code>作为数组的索引，数组中键<code>i</code>处对应的存储的是它的对应值，这种方式就可以快速访问任意键的值。</p>
<p>散列查找算法步骤：通过散列函数将被查找的键转化为数组的一个索引(理想情况是每个键对应一个索引，实际情况是会出现多个键值对应同一个索引) -&gt; 处理碰撞冲突(应用拉链法和线性探测法)</p>
</blockquote>
<h3 id="基于拉链法的哈希表"><a href="#基于拉链法的哈希表" class="headerlink" title="基于拉链法的哈希表"></a>基于拉链法的哈希表</h3><p>在查找的<code>key</code>经过Hash函数转化为数组的索引之后，便需要处理这样的一个情况，即某些<code>key</code>在经过Hash函数转化之后会出现相同的索引值，这时候就需要进行–碰撞处理。</p>
<p>一种方法是将大小为M的数组并将其中的每个元素都指向一条链表，对应链表当中的每个结点都存储了该处元素对应的散列值所包含的键值对，这个方法被成为拉链法。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328161219.jpg" alt=""></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>通过<code>key</code>计算对应的Hashcode</li>
<li>根据Hashcode定位到数组中的某个位置array<a href="该位置对应一条链表">Hashcode</a></li>
<li>若链表为空，直接插入，否则进行add操作</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChaingingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">//key-value总数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;  <span class="comment">//HashTable的大小</span></div><div class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st; <span class="comment">// 存放链表对象的数组</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChaingingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</div><div class="line">        <span class="comment">//创建M条链表</span></div><div class="line">        <span class="keyword">this</span>.M = M;</div><div class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</div><div class="line">            st[i] = <span class="function">ne <span class="title">SequentialSearchST</span><span class="params">()</span></span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> (Value) st[hash(key)].get(key);&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;st[hash(key)].put(key, value);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于线性探测法的哈希表"><a href="#基于线性探测法的哈希表" class="headerlink" title="基于线性探测法的哈希表"></a>基于线性探测法的哈希表</h3><p>实现HashTable的另一种方式是通过大小为M的数组保存N的<code>key-value</code>对，其中 M &gt; N; 在这个方法当中是通过数组空位来解决冲突碰撞的问题。</p>
<p><img src="http://algs4.cs.princeton.edu/34hash/images/linear-probing.png" alt=""></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>在发生碰撞的时候，即一个键的散列值被另一个不同的键占用，此时直接检查散列表当中的下一个位置(对索引值+1)，对应三种结果</p>
<ol>
<li>命中，该位置的键即被查找的键的位置</li>
<li>未命中，键为空</li>
<li>继续查找，该位置的键和被查找的键不同</li>
</ol>
<p>关于线性检测，在查看参考资料的时候看到一个很形象的比喻，我们可以把线性检测操作看作是一次停车，当当前车位已经停车之后，则继续向前直到找到可放入的车位。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg" alt=""></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">//符号表中键值对总数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>; <span class="comment">//线性探测表的大小</span></div><div class="line">    <span class="keyword">private</span> Key[] keys;</div><div class="line">    <span class="keyword">private</span> Value[] values;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</div><div class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</div><div class="line">        values = (Value[]) <span class="keyword">new</span> Object[M];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;&#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (N &gt;= M/<span class="number">2</span>) resize(<span class="number">2</span>*M);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M ) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                values[i] = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        keys[i] = key;</div><div class="line">        values[i] = value;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i+<span class="number">1</span>) % M ) &#123;</div><div class="line">            <span class="keyword">if</span> (keys[i].equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> values[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>一般的，在应用查找算法的时候，散列表的性能会比红黑树性能好很多，但是这也和 Hash Function的计算效率相关联。但是对于散列表来说，它并不能保证顺序，因此对于顺序操作还是应该采用树结构。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328190932.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">Princeton-Algorithm 4th, Searching Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Advanced Sorting]]></title>
      <url>https://woofww.github.io/2016/12/07/Algorithm-Advanced-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>对于归并的概念，简而言之就是分治，对于独立的部分单独地进行排序然后再将排序完成的子数组进行合并，最终完成全部排序。但是归并排序由于需要额外数组，所以空间复杂度也比较高。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/merge-sort_8993d8.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h4><ul>
<li><p>Example:</p>
<p>  <img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt="enter image description here"></p>
</li>
<li><p>原地归并为直接将两个不同的有序数组合并到第三个数组当中，当然该数组最终是有序的。原理：首先将原数组存放至一个临时数组当中，并通过指定参数如i和j指向数组的起始位置<code>low</code>和中间位置<code>middle</code>。以此保证了原数组左右两边是有序的。从左右两个独立数组的头部开始扫描数组，此时对<code>array[i]</code>和<code>array[j]</code>进行比较，将较大值放入临时数组。</p>
</li>
</ul>
<ul>
<li>抽象地描述便是<code>merge(a, low, middle, high)</code>，该方法会将<code>a[low..middle]</code>，<code>a[middle..high]</code>归并为一个有序的数组并将结果存放在<code>a[low..high]</code>当中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data_new = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</div><div class="line">        <span class="keyword">int</span> left = low, right = middle+<span class="number">1</span>; <span class="comment">// 定义双指针</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= data.length-<span class="number">1</span> ; i++ ) &#123;</div><div class="line">            data_new[i] = data[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= high; i++ ) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; middle) data[i] = data_new[right++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high ) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data_new[left] &lt; data_new[right]) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> data[i] = data_new[right++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h4><p>自顶向下排序实现了一种递归归并的方法， 实现了一种典型的分治思想，运用迭代的思想将两个独立的子数组进行排序，并最终完成归并；对于一个长度为N的任意数组， 自顶向下归并排序需要进行1/2NloN到NlgN的比较</p>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;<span class="comment">//此种情况结束递归，即无法再继续进行分割</span></div><div class="line">    <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;</div><div class="line">    sort(data, low, middle);<span class="comment">//对数组左半部分进行排序</span></div><div class="line">    sort(data, middle+<span class="number">1</span>, high);<span class="comment">//对右半部份进行排序</span></div><div class="line">    merge(data, low, middle, high);<span class="comment">//不断进行递归，直到无法继续进行直到结束</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><ul>
<li><p>对于规模较小的子数组使用插入排序</p>
<p>由于归并排序中频繁的使用了递归的方式进行操作，操作过程中对于一些小规模的数组，可以先对其进行插入排序，因为对于子数组(长度小于15)的排序，插入排序的效率会更高一些，运行时间一般可以缩短10%到15%。</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  在merge之前先对数组进行判断是否已经有序，如果有序则直接跳过merge步骤</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!data[i+<span class="number">1</span>] &lt; data[i] ) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>快速排序同样属于一种分治算法，将一个数组分为两个子数组，然后将两部分进行独立的排序。</p>
<blockquote>
<p>和归并排序的区别：对于归并排序是先对独立的子数组进行排序，然后在将排序后的子数组进行归并而将整个数组进行排序。快速排序在将子数组排序之后，整体数组也同时完成了排序。</p>
</blockquote>
<p><img src="http://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort_b49af5.gif" alt="enter image description here"></p>
</li>
<li><p>步骤</p>
<ol>
<li>对数组进行shuffle，保证快速排序的性能</li>
<li>切分数组(需要满足如下条件)<ul>
<li>对于某个<code>j</code>, <code>a[j]</code>已经排定</li>
<li><code>a[low]</code>到<code>a[j-1]</code>的所有元素都不大于<code>a[j]</code></li>
<li><code>a[j+1]</code>到<code>a[high]</code>的所有元素都不小于<code>a[j]</code></li>
</ul>
</li>
<li>递归的对数组进行排序</li>
</ol>
</li>
<li><p>切分(Partition)</p>
<p>  切分操作一般都选择数组的第一个元素作为切分元素，下一步从数组的左侧向右扫描，直到发现大于切分元素即跳出扫描循环。另一部分从数组的右侧向左扫描，当发现小于切分元素即跳出第二个扫描循环。当扫描指针相遇的时候，跳出大循环。</p>
<p>  <img src="http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png" alt="enter image description here"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;<span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//从数组两侧进行扫描</span></div><div class="line">        <span class="keyword">while</span>(data[++i] &lt; compare) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;<span class="comment">//当左指针大于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">while</span> (compare &lt; data[--j]) <span class="keyword">if</span> (j == low) <span class="keyword">break</span>;<span class="comment">//当右指针小于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;<span class="comment">//当左右指针相遇的时候，跳出循环体</span></div><div class="line">        <span class="comment">//元素交换</span></div><div class="line">        temp = data[i];</div><div class="line">        data[i] = data[j];</div><div class="line">        data[j] = temp;</div><div class="line">    &#125;</div><div class="line">    temp = data[low];</div><div class="line">    data[low] = data[j];</div><div class="line">    data[j] = temp;</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">    <span class="comment">//将首元素和位置[j]的元素进行交换</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="改善快速排序性能的简单方法"><a href="#改善快速排序性能的简单方法" class="headerlink" title="改善快速排序性能的简单方法"></a>改善快速排序性能的简单方法</h4><ul>
<li>类似于归并排序，对于小数组，插入排序的效率更高一些</li>
<li><p>由于递归的原因，排序方法也会在小数组当中调用自己</p>
</li>
<li><p>三取样切分</p>
<ul>
<li>通过使用子数组一部分元素的中位数来对数组进行切分。</li>
</ul>
</li>
</ul>
<h4 id="三向切分-熵最优排序"><a href="#三向切分-熵最优排序" class="headerlink" title="三向切分(熵最优排序)"></a>三向切分(熵最优排序)</h4><p>Example:</p>
<p><img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort-3-way_d176ee.gif" alt="enter image description here"></p>
<p>该情况适用于数组当中存在大量重复元素的样例。当切分的元素重复的时候，不需要对其进行排序即可。切分的三部分分别为大于小于等于元素的数组元素</p>
<ul>
<li><code>data[i]</code> &lt; <code>compare</code>元素 二者交换 <code>i</code> 和 <code>lt</code>同时增加</li>
<li><code>data[i]</code> &gt; <code>compare</code>元素 和<code>data[gt]``交换</code>gt`减少</li>
<li><code>data[i]</code> = <code>compare</code>元素 <code>i++</code></li>
</ul>
<p>这样的操作能够保证数组元素不变，同时缩小<code>gt</code>-<code>i</code>的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threeWaySort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>; <span class="comment">//递归结束条件</span></div><div class="line">    <span class="keyword">int</span> lt = low, i = low + <span class="number">1</span>, gt = high; <span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (i &lt;= gt)&#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[lt];</div><div class="line">            data[lt] = temp;</div><div class="line">            i++;</div><div class="line">            lt++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[gt];</div><div class="line">            data[gt] = temp;</div><div class="line">            gt--;</div><div class="line">        &#125;<span class="keyword">else</span> i++;</div><div class="line">    &#125;</div><div class="line">    threeWaySort(data, low, lt-<span class="number">1</span>);</div><div class="line">    threeWaySort(data, gt+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/heap-sort_f79bb1.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>二叉堆一种可以有效支持优先队列操作的数据结构。在二叉堆数组当中，每个元素都应该保证大于等于另外两个特定位置的元素，以此类推。二叉堆是一组能够用堆有序的完全二叉树排序的元素，其在数组当中按层级排列。</p>
<p>Example:</p>
<p><img src="http://algs4.cs.princeton.edu/24pq/images/heap-representations.png" alt="enter image description here"></p>
<h3 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h3><ul>
<li><p>通过使用优先队列构造排序方法，将所有的元素插入到查找最小元素的优先队列当中，堆排序主要包含两个部分，1. 将原始数组构造为有序堆 2. 不断将根节点移出树结构，同时重新构造有序堆。</p>
<ul>
<li><p>堆的构造</p>
<p>通过对数据从右至左进行不断的sink操作，对于数组中的每一个位置，都能够认为是每个子堆的根节点(也包含树的最底层节点)。对于扫描数组只需要扫描其容量的一半，这样可以跳过大小为1的子堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N = data.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- ) &#123;</div><div class="line">        sink(data, i, N);<span class="comment">//该部分目的构造有序堆</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</div><div class="line">        exchange(data, <span class="number">1</span>, N--);</div><div class="line">        sink(data, <span class="number">1</span>, N);</div><div class="line">        <span class="comment">//移出每个堆中的最大元素，完成排序</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="排序算法复杂度总结"><a href="#排序算法复杂度总结" class="headerlink" title="排序算法复杂度总结"></a>排序算法复杂度总结</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316203033.jpg" alt="enter image description here"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Elementary Sorting]]></title>
      <url>https://woofww.github.io/2016/11/28/Algorithm-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法的目的是将数组元素的主键依照某种方式进行排序。排序后索引较大的主键大于或等于索引较小的主键。</p>
<p>在java当中，元素通常都是对象，对主键的抽象描述是通过一种内部构建的机制来完成的(java中的Comparable接口)</p>
<h3 id="比较函数的性质"><a href="#比较函数的性质" class="headerlink" title="比较函数的性质"></a>比较函数的性质</h3><p>比较函数需要满足如下性质才能是的排序函数正常执行：</p>
<ol>
<li>反对称性：a &lt;= b且b &lt;= a推出a = b</li>
<li>传递性：a &lt;= b且b &lt;= c推出a &lt;= c</li>
<li>整体性：存在a &lt;= b或者b &lt;= a或者二者同时存在</li>
</ol>
<a id="more"></a>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><ul>
<li><p>less: 判断两个相比较的元素是否存在小于关系</p>
</li>
<li><p>exchange：交换比较数组中的元素</p>
</li>
<li><p>顺序检查： 检查排序的数组是否已经完成排序</p>
</li>
</ul>
<h3 id="Template-of-Sorting-Algorithm"><a href="#Template-of-Sorting-Algorithm" class="headerlink" title="Template of Sorting Algorithm"></a>Template of Sorting Algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">/* Code */</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> v.Comparable(w) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        Comparable t = a[i];</div><div class="line">        a[i] = a[j];</div><div class="line">        a[j] = t;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Print Array</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</div><div class="line">            System.out.println(a[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Test if the Array is sorted</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(less(a[i]), a[i-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String[] a = In.readString();</div><div class="line">        sort(a);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</div><div class="line">        show(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基本排序分类"><a href="#基本排序分类" class="headerlink" title="基本排序分类"></a>基本排序分类</h2><h3 id="冒泡排序-复杂度-O-n-2"><a href="#冒泡排序-复杂度-O-n-2" class="headerlink" title="冒泡排序(复杂度 O(n^2))"></a>冒泡排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/bubble-sort_ee720b.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  冒泡排序通过每次对需要排序的<code>item</code>的每一个相邻项进行比较，若前一个比后一个大，则进行交换。通过这个操作，每一趟排列可以将<code>item</code>中的最大值置于最高位，在经过<code>n-1</code>趟循环之后，排列结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="comment">//总共外部循环需要n-1次，每次迭代排序数组需要n-1次</span></div><div class="line">        <span class="comment">//同时需要考虑数据交换</span></div><div class="line">        <span class="comment">//冒泡排序每经过一次外层循环都可以把最高位归位</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=data.length-<span class="number">1</span>; j++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=data.length-<span class="number">1</span>-j; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (data[i-<span class="number">1</span>]&gt;data[i])&#123;</div><div class="line">                    temp = data[i-<span class="number">1</span>];</div><div class="line">                    data[i-<span class="number">1</span>] = data[i];</div><div class="line">                    data[i] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序-复杂度-O-n-2"><a href="#选择排序-复杂度-O-n-2" class="headerlink" title="选择排序(复杂度 O(n^2))"></a>选择排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/selection-sort_f03ab6.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  在数组中查询最小的元素，然后将其与数组中的第一个元素进行交换。当数组的第一个元素为最小元素的时候(将其与自身进行交换)。下一步在其余元素中找到最小的元素，将其与数组中的第二个元素进行交换。循环往复，直到将整个数组进行了排序。基本概念就是在剩余元素当中寻找最小者。</p>
</li>
<li><p>复杂度</p>
<p>  对于选择排序来说，当数组长度为<code>N</code>, 其大约需要<code>N^2/2</code>次比较与<code>N</code>次交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length-<span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="comment">//由于选择排序每经过一次外层循环，标记点的左侧为已完成排序的内容</span></div><div class="line">            <span class="keyword">int</span> min = i;<span class="comment">//设置初始标记点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; data.length; j++) &#123;</div><div class="line">                <span class="comment">//内层循环用于和标记点进行比较</span></div><div class="line">                <span class="keyword">if</span> (data[min] &gt; data[j])&#123;</div><div class="line">                    min = j;<span class="comment">//如果小于标记点，便替换标记点，当内层循环结束后，定位了此轮循环最小值的位置，跳出循环后将其</span></div><div class="line">                    <span class="comment">//初始标记点进行替换即可</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进行交换</span></div><div class="line">            <span class="keyword">int</span> temp = data[i];</div><div class="line">            data[i] = data[min];</div><div class="line">            data[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序-复杂度-O-n-2"><a href="#插入排序-复杂度-O-n-2" class="headerlink" title="插入排序(复杂度 O(n^2))"></a>插入排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="http://img.blog.csdn.net/20140602175214796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  插入排序通过对索引左侧的数据进行不断的排列，使得索引左侧的数据保持有序，同时用未排序的数字和已排序的队列进行比较，当比它大，则进行交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.length; i++)&#123;</div><div class="line">            <span class="comment">//内部循环是为了进行将对应指针左侧进行排列，并将较大的数字向右移动</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="keyword">if</span> (data[j]&lt;data[j-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = data[j-<span class="number">1</span>];</div><div class="line">                    data[j-<span class="number">1</span>] = data[j];</div><div class="line">                    data[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序-复杂度介于O-nlogn到n-2"><a href="#希尔排序-复杂度介于O-nlogn到n-2" class="headerlink" title="希尔排序 复杂度介于O(nlogn到n^2)"></a>希尔排序 复杂度介于O(nlogn到n^2)</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/shell-sort_5c15b3.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念<br>  希尔排序是对于插入排序的一种优化，插入排序当数值较小的<code>key</code>排在靠后的位置时，排序的效率是比较低的，因为在应用插入排序的时候，它只会交换相邻元素。<br>  希尔排序通过交换不相邻元素的位置，使得较小的值能够被更快地移动到开头位置，其应用思想被称为<code>h</code>有序数组。<br>  <img src="http://algs4.cs.princeton.edu/21elementary/images/h-sorted.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &lt;= data.length) step = <span class="number">3</span>*step + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &gt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//此步先对外部循环进行判断，即每次step需要的运行次数</span></div><div class="line">            <span class="comment">//此处外部循环导致越界，尤其在数组边界的时候</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= step; j -= step)&#123;</div><div class="line">                    <span class="comment">//在交换时候考虑超过数组边界问题</span></div><div class="line">                    <span class="keyword">if</span> (data[j-step] &gt; data[j])&#123;</div><div class="line">                        <span class="keyword">int</span> temp = data[j-step];</div><div class="line">                        data[j-step] = data[j];</div><div class="line">                        data[j] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            step = step/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/21elementary/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Data Structure-Stack]]></title>
      <url>https://woofww.github.io/2016/11/24/Data%20Structure-Stack/</url>
      <content type="html"><![CDATA[<h2 id="Data-Structure-Princeton-Algorithm"><a href="#Data-Structure-Princeton-Algorithm" class="headerlink" title="Data Structure-Princeton Algorithm"></a>Data Structure-Princeton Algorithm</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><h4 id="Basic-API-of-Stack"><a href="#Basic-API-of-Stack" class="headerlink" title="Basic API of Stack"></a>Basic API of Stack</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;</span></div><div class="line"></div><div class="line"><span class="title">Stack</span><span class="params">()</span> <span class="comment">//创建空栈</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> <span class="comment">//向栈中添加元素</span></div><div class="line"></div><div class="line">Item <span class="title">pop</span><span class="params">()</span> <span class="comment">//从栈中删除最近添加元素</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 检测栈是否为空</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="comment">//栈中包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="Stack的实现方式"><a href="#Stack的实现方式" class="headerlink" title="Stack的实现方式"></a>Stack的实现方式</h2><ul>
<li><p>Linked_list</p>
<blockquote>
<p>定义： 链表是一种递归的数据结构，它可以为空(null)，也可以指向对一个节点的(node)的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。 结点可作为任意数据类型的抽象实体。</p>
</blockquote>
</li>
</ul>
<h3 id="Stack的linkedlist-实现"><a href="#Stack的linkedlist-实现" class="headerlink" title="Stack的linkedlist 实现"></a>Stack的linkedlist 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">inner <span class="class"><span class="keyword">class</span></span></div><div class="line"><span class="title">private</span> <span class="title">class</span> <span class="title">Node</span>&#123;</div><div class="line">    String item;</div><div class="line">    Node next;</div><div class="line">&#125;</div><div class="line"><span class="comment">//对节点进行初始化</span></div></pre></td></tr></table></figure>
<ul>
<li><p>Push 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-insert-front.png" alt="enter image description here"></p>
</li>
<li><p>Pop 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-remove-first.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;<span class="comment">// Initialize the first node of the linkedlist</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//number of items</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        String item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// or N == 0;</span></div><div class="line">        <span class="comment">//judge if the stack is empty</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</div><div class="line">        Node oldfirst = first;</div><div class="line">        <span class="comment">//将当前的首位赋值给临时的oldfirst</span></div><div class="line">        first = <span class="keyword">new</span> Node();</div><div class="line">        first.item = item;</div><div class="line">        <span class="comment">//将压入stack的item复制给新的first</span></div><div class="line">        first.next = oldfirst;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        String item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Stack的Resizing-Array实现"><a href="#Stack的Resizing-Array实现" class="headerlink" title="Stack的Resizing Array实现"></a>Stack的Resizing Array实现</h3><ul>
<li>Array<blockquote>
<p>关于定容数组对于栈的实现, 在初始化栈的时候，必须要先设定栈的最大容量。同时数组一旦被创建，其大小便无法进行改变。当数组容量被设置过大的时候，又会浪费大量的内存。然而在用例过大的时候，也会很容易发生溢出问题，因此实现栈容量的动态调节是非常有必要的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizingArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];<span class="comment">// java不支持泛型数组，所以需要进行强制转换</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</div><div class="line">        <span class="comment">//将stack移动到大小为max的数组当中</span></div><div class="line">        Item[] temp = (Item[]) <span class="keyword">new</span> Object[max];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            temp[i] = a[i];</div><div class="line">        &#125;</div><div class="line">        a = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (N == a.length) &#123;</div><div class="line">            resize(<span class="number">2</span>*a.length);</div><div class="line">            a[N++] = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        Item item = a[--N];</div><div class="line">        a[N] = <span class="keyword">null</span>;<span class="comment">//避免对象游离，成为“孤儿”</span></div><div class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N == a.length/<span class="number">4</span>) &#123;</div><div class="line">            resize(a.length/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseArrayIterator();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = N;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a[--i];&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对象游离<blockquote>
<p>java的GC策略是将所有无法被访问的对象的内存， 在上述Pop操作的代码当中，被弹出的元素的引用仍旧存在于数组当中。但是这个元素实际上已经成为一个“孤儿”， 即它永远不会再被访问了。 除非这个引用被覆盖，否则java的GC机制永远无法知道这点。因此为了避免出现这种现象，我们需要将弹出的元素设置为null，则这个用例可正常被作为垃圾进行回收。</p>
</blockquote>
</li>
</ul>
<h2 id="上述两种方式的比较"><a href="#上述两种方式的比较" class="headerlink" title="上述两种方式的比较"></a>上述两种方式的比较</h2><ul>
<li>Linkedlist<ul>
<li>最差情况下，每一步操作都要消耗恒定时间</li>
<li>需要花费额外的时间和空间对链接进行处理</li>
</ul>
</li>
<li>Resizing-Array<ul>
<li>每一步操作都需要花费平均的摊销时间</li>
<li>消耗更少量的空间</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/13stacks/" target="_blank" rel="external">Princeton-Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Union Find]]></title>
      <url>https://woofww.github.io/2016/11/12/Union-Find-Algorithm/</url>
      <content type="html"><![CDATA[<h2 id="Princeton-Algorithm"><a href="#Princeton-Algorithm" class="headerlink" title="Princeton - Algorithm"></a>Princeton - Algorithm</h2><p>1st week：Union-Find</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有N个元素，从0~N-1编号，假如两个元素之间的连接视为通路，当执行多次任意的两个元素之间的连接之后，如何判断两个元素能够经由已有路径相连通。对于连接的动作称为union，判断是否连接的操作称为find，如下图<br><a id="more"></a><br><img src="http://obpbs8a3y.bkt.clouddn.com/1.jpg" alt="enter image description here"><br><img src="http://img.blog.csdn.net/20130901114328078" alt="enter image description here"></p>
<p>从上图中可以看出，0, 1, 2, 5, 6, 7 中的任意两个元素都是相连的，同样 3, 4, 8, 9 中任意两个元素也是互连的，但是第一个集合和第二个集合的元素却是无法连通的。</p>
<p>实际操作中可用于在一个庞大的网路环境下，如何迅速判断某两个点是否相连，如下图：</p>
<p><img src="http://i2.piimg.com/567571/38bfecc955fdf85c.jpg" alt="enter image description here"></p>
<h3 id="有效算法的开发步骤"><a href="#有效算法的开发步骤" class="headerlink" title="有效算法的开发步骤"></a>有效算法的开发步骤</h3><ol>
<li>构建需求模型</li>
<li>寻找所需算法</li>
<li>运行算法检测速度和内存是否符合要求</li>
<li>效率差或者达不到要求，找出问题的原因</li>
<li>寻求解决办法，循环上述步骤直到满意为止</li>
</ol>
<h3 id="首先确认Union和Find操作应该满足怎样的条件："><a href="#首先确认Union和Find操作应该满足怎样的条件：" class="headerlink" title="首先确认Union和Find操作应该满足怎样的条件："></a>首先确认Union和Find操作应该满足怎样的条件：</h3><p>find操作：确认两个对象是否连接：<br>自反性：P连接到Q<br>对称性：P连接到Q，则 Q连接到P<br>传递性：P连接到Q，Q连接到R，则P也连接到R</p>
<p>union操作：连接在一起的对象，我们统称为一个连接集合，执行一次union操作就相当于将两个对象所在的集合连接到一起，组成一个新的集合。新集合中的任意两个成员也应该都处于连接状态。</p>
<h3 id="Connected-Component"><a href="#Connected-Component" class="headerlink" title="Connected Component"></a>Connected Component</h3><p>Concept: 相连的节点所构成的集合</p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>并查集提供了两种操作：</p>
<ol>
<li>查找操作(find)：检测两个节点是否相连</li>
<li>合并操作(Union): 将两节点进行链接</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>并查集算法需要实现如下目标：</p>
<ol>
<li>查找对象的数量N可以非常大</li>
<li>操作的次数M可以非常大</li>
<li>Find和Union操作可以随意调用</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>数据结构<br>假设有N个节点，该算法的数据结构为一个包含N个整数的数组id[]</p>
<h3 id="Find操作"><a href="#Find操作" class="headerlink" title="Find操作"></a>Find操作</h3><p>判断p q两个节点是否相连，通过判断id[p]和id[q]对应的数值是否一致</p>
<h3 id="Union操作"><a href="#Union操作" class="headerlink" title="Union操作"></a>Union操作</h3><p>将两节点合作是通过将被合并的节点q的id值设为节点p的id值</p>
<p>但是合并操作的缺点是在进行Union操作的时候，需要遍历整个数组，因此算法开销比较大</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>每一次合并的复杂度为N，当合并次数非常大的时候，趋近于N，运算的复杂度则为N^2,因此该算法不适合较大规模运算。</p>
<p>查找操作的复杂度为1.</p>
<h2 id="Quick-Union-Lazy-Approach"><a href="#Quick-Union-Lazy-Approach" class="headerlink" title="Quick Union(Lazy Approach)"></a>Quick Union(Lazy Approach)</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>整型数组id[],大小为N</li>
<li>Interpretation: 数组的每个元素id[i]指的是i的上一级为id[i]</li>
<li>i的根节点 id[id[id[…id[]…]]]</li>
</ol>
<h3 id="Find操作-1"><a href="#Find操作-1" class="headerlink" title="Find操作"></a>Find操作</h3><p>如果P和Q两个值对应相同的根节点，则为找到</p>
<h3 id="Union操作-1"><a href="#Union操作-1" class="headerlink" title="Union操作"></a>Union操作</h3><p>如果需要将p q进行连接，则需要将二者对应的根节点数设为相同值</p>
<p><img src="http://img.blog.csdn.net/20130901134321640" alt="enter image description here"></p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>在最坏的情况下，查找操作的复杂度仍将达到N</p>
<h2 id="Quick-Union的优化"><a href="#Quick-Union的优化" class="headerlink" title="Quick Union的优化"></a>Quick Union的优化</h2><p>通过每个节点增加quality的概念，使得quality小的component位于大的component之下，从而避免了树形结构过高的问题。</p>
<p>如下图展示了树形结构深度优化后的效果<br><img src="http://img.blog.csdn.net/20140602174057171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>合并操作的最坏复杂度为lgN,查询操作的最坏复杂度为lgN</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>在查找根节点时，将路径上的所有节点进行路径压缩，理论上得到的find操作的复杂度为1.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HotKey of Intellij IDEA]]></title>
      <url>https://woofww.github.io/2016/01/17/HotKey%20of%20Intellij%20IDEA/</url>
      <content type="html"><![CDATA[<p><em>Intellij IDEA作为一款能力非常强大的集成开发工具，为日常的程序开发带来了很大的便利，同时内部自带的快捷键也极大地提升了开发效率，本文将主要对Intellij IDEA中的常用快捷键进行总结</em><br><a id="more"></a></p>
<h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">Ctrl+E，最近的文件</div><div class="line">Ctrl+Shift+E，最近更改的文件</div><div class="line">Shift+Click，可以关闭文件</div><div class="line">Ctrl+[ OR ]，可以跑到大括号的开头与结尾</div><div class="line">Ctrl+F12，可以显示当前文件的结构</div><div class="line">Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择</div><div class="line">Ctrl+N，可以快速打开类</div><div class="line">Ctrl+Shift+N，可以快速打开文件</div><div class="line">Alt+Q，可以看到当前方法的声明</div><div class="line">Ctrl+P，可以显示参数信息</div><div class="line">Ctrl+Shift+Insert，可以选择剪贴板内容并插入</div><div class="line">Alt+Insert，可以生成构造器/Getter/Setter等</div><div class="line">Ctrl+Alt+V，可以引入变量。例如：new String();  自动导入变量定义</div><div class="line">Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch</div><div class="line">Ctrl+Enter，导入包，自动修正</div><div class="line">Ctrl+Alt+L，格式化代码</div><div class="line">Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作</div><div class="line">Ctrl+Alt+O，优化导入的类和包</div><div class="line">Ctrl+R，替换文本</div><div class="line">Ctrl+F，查找文本</div><div class="line">Ctrl+Shift+Space，自动补全代码</div><div class="line">Ctrl+空格，代码提示（与系统输入法快捷键冲突）</div><div class="line">Ctrl+Shift+Alt+N，查找类中的方法或变量</div><div class="line">Alt+Shift+C，最近的更改</div><div class="line">Alt+Shift+Up/Down，上/下移一行</div><div class="line">Shift+F6，重构 - 重命名</div><div class="line">Ctrl+X，删除行</div><div class="line">Ctrl+D，复制行</div><div class="line">Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）</div><div class="line">Ctrl+J，自动代码（例如：serr）</div><div class="line">Ctrl+Alt+J，用动态模板环绕</div><div class="line">Ctrl+H，显示类结构图（类的继承层次）</div><div class="line">Ctrl+Q，显示注释文档</div><div class="line">Alt+F1，查找代码所在位置</div><div class="line">Alt+1，快速打开或隐藏工程面板</div><div class="line">Ctrl+Alt+left/right，返回至上次浏览的位置</div><div class="line">Alt+left/right，切换代码视图</div><div class="line">Alt+Up/Down，在方法间快速移动定位</div><div class="line">Ctrl+Shift+Up/Down，向上/下移动语句</div><div class="line">F2 或 Shift+F2，高亮错误或警告快速定位</div><div class="line">Tab，代码标签输入完成后，按 Tab，生成代码</div><div class="line">Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失</div><div class="line">Alt+F3，逐个往下查找相同文本，并高亮显示</div><div class="line">Ctrl+Up/Down，光标中转到第一行或最后一行下</div><div class="line">Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）</div><div class="line">Ctrl+Alt+B，跳转到方法实现处</div><div class="line">Ctrl+Shift+Backspace，跳转到上次编辑的地方</div><div class="line">Ctrl+O，重写方法</div><div class="line">Ctrl+Alt+Space，类名自动完成</div><div class="line">Ctrl+Alt+Up/Down，快速跳转搜索结果</div><div class="line">Ctrl+Shift+J，整合两行</div><div class="line">Alt+F8，计算变量值</div><div class="line">Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本</div><div class="line">Ctrl+Alt+Shift+V，简单粘贴</div><div class="line">Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口</div><div class="line">F12，把焦点从编辑器移到最近使用的工具窗口</div><div class="line">Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器</div><div class="line">Ctrl+W，可以选择单词继而语句继而行继而函数</div><div class="line">Ctrl+Shift+W，取消选择光标所在词</div><div class="line">Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置</div><div class="line">Ctrl+I，实现方法</div><div class="line">Ctrl+Shift+U，大小写转化</div><div class="line">Ctrl+Y，删除当前行</div><div class="line">Shift+Enter，向下插入新行</div><div class="line">psvm/sout，main/System.out.println(); Ctrl+J，查看更多</div><div class="line">Ctrl+Shift+F，全局查找</div><div class="line">Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找</div><div class="line">Ctrl+Shift+S，高级搜索</div><div class="line">Ctrl+U，转到父类</div><div class="line">Ctrl+Alt+S，打开设置对话框</div><div class="line">Alt+Shift+Inert，开启/关闭列选择模式</div><div class="line">Ctrl+Alt+Shift+S，打开当前项目/模块属性</div><div class="line">Ctrl+G，定位行</div><div class="line">Alt+Home，跳转到导航栏</div><div class="line">Ctrl+Enter，上插一行</div><div class="line">Ctrl+Backspace，按单词删除</div><div class="line">Ctrl+&quot;+/-&quot;，当前方法展开、折叠</div><div class="line">Ctrl+Shift+&quot;+/-&quot;，全部展开、折叠</div></pre></td></tr></table></figure>
<h3 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="调试部分、编译"></a>调试部分、编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Ctrl+F2，停止</div><div class="line">Alt+Shift+F9，选择 Debug</div><div class="line">Alt+Shift+F10，选择 Run</div><div class="line">Ctrl+Shift+F9，编译</div><div class="line">Ctrl+Shift+F10，运行</div><div class="line">Ctrl+Shift+F8，查看断点</div><div class="line">F8，步过</div><div class="line">F7，步入</div><div class="line">Shift+F7，智能步入</div><div class="line">Shift+F8，步出</div><div class="line">Alt+Shift+F8，强制步过</div><div class="line">Alt+Shift+F7，强制步入</div><div class="line">Alt+F9，运行至光标处</div><div class="line">Ctrl+Alt+F9，强制运行至光标处</div><div class="line">F9，恢复程序</div><div class="line">Alt+F10，定位到断点</div><div class="line">Ctrl+F8，切换行断点</div><div class="line">Ctrl+F9，生成项目</div><div class="line">Alt+1，项目</div><div class="line">Alt+2，收藏</div><div class="line">Alt+6，TODO</div><div class="line">Alt+7，结构</div><div class="line">Ctrl+Shift+C，复制路径</div><div class="line">Ctrl+Alt+Shift+C，复制引用，必须选择类名</div><div class="line">Ctrl+Alt+Y，同步</div><div class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</div><div class="line">Shift+F12，还原默认布局</div><div class="line">Ctrl+Shift+F12，隐藏/恢复所有窗口</div><div class="line">Ctrl+F4，关闭</div><div class="line">Ctrl+Shift+F4，关闭活动选项卡</div><div class="line">Ctrl+Tab，转到下一个拆分器</div><div class="line">Ctrl+Shift+Tab，转到上一个拆分器</div></pre></td></tr></table></figure>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ctrl+Alt+Shift+T，弹出重构菜单</div><div class="line">Shift+F6，重命名</div><div class="line">F6，移动</div><div class="line">F5，复制</div><div class="line">Alt+Delete，安全删除</div><div class="line">Ctrl+Alt+N，内联</div></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Ctrl+F，查找</div><div class="line">Ctrl+R，替换</div><div class="line">F3，查找下一个</div><div class="line">Shift+F3，查找上一个</div><div class="line">Ctrl+Shift+F，在路径中查找</div><div class="line">Ctrl+Shift+R，在路径中替换</div><div class="line">Ctrl+Shift+S，搜索结构</div><div class="line">Ctrl+Shift+M，替换结构</div><div class="line">Alt+F7，查找用法</div><div class="line">Ctrl+Alt+F7，显示用法</div><div class="line">Ctrl+F7，在文件中查找用法</div><div class="line">Ctrl+Shift+F7，在文件中高亮显示用法</div></pre></td></tr></table></figure>
<h3 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alt+~，VCS 操作菜单</div><div class="line">Ctrl+K，提交更改</div><div class="line">Ctrl+T，更新项目</div><div class="line">Ctrl+Alt+Shift+D，显示变化</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
