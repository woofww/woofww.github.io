<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Algorithm-Advanced Sorting]]></title>
      <url>http://yoursite.com/2016/12/07/Algorithm-Advanced-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>对于归并的概念，简而言之就是分治，对于独立的部分单独地进行排序然后再将排序完成的子数组进行合并，最终完成全部排序。但是归并排序由于需要额外数组，所以空间复杂度也比较高。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/merge-sort_8993d8.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h4><ul>
<li><p>Example:</p>
<p>  <img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt="enter image description here"></p>
</li>
<li><p>原地归并为直接将两个不同的有序数组合并到第三个数组当中，当然该数组最终是有序的。原理：首先将原数组存放至一个临时数组当中，并通过指定参数如i和j指向数组的起始位置<code>low</code>和中间位置<code>middle</code>。以此保证了原数组左右两边是有序的。从左右两个独立数组的头部开始扫描数组，此时对<code>array[i]</code>和<code>array[j]</code>进行比较，将较大值放入临时数组。</p>
</li>
</ul>
<ul>
<li>抽象地描述便是<code>merge(a, low, middle, high)</code>，该方法会将<code>a[low..middle]</code>，<code>a[middle..high]</code>归并为一个有序的数组并将结果存放在<code>a[low..high]</code>当中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data_new = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</div><div class="line">        <span class="keyword">int</span> left = low, right = middle+<span class="number">1</span>; <span class="comment">// 定义双指针</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= data.length-<span class="number">1</span> ; i++ ) &#123;</div><div class="line">            data_new[i] = data[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= high; i++ ) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; middle) data[i] = data_new[right++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high ) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data_new[left] &lt; data_new[right]) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> data[i] = data_new[right++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h4><p>自顶向下排序实现了一种递归归并的方法， 实现了一种典型的分治思想，运用迭代的思想将两个独立的子数组进行排序，并最终完成归并；对于一个长度为N的任意数组， 自顶向下归并排序需要进行1/2NloN到NlgN的比较；<a href="http://algs4.cs.princeton.edu/22mergesort/" target="_blank" rel="external"><code>(参考 Reference)</code></a></p>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;<span class="comment">//此种情况结束递归，即无法再继续进行分割</span></div><div class="line">    <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;</div><div class="line">    sort(data, low, middle);<span class="comment">//对数组左半部分进行排序</span></div><div class="line">    sort(data, middle+<span class="number">1</span>, high);<span class="comment">//对右半部份进行排序</span></div><div class="line">    merge(data, low, middle, high);<span class="comment">//不断进行递归，直到无法继续进行直到结束</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><ul>
<li><p>对于规模较小的子数组使用插入排序</p>
<p>由于归并排序中频繁的使用了递归的方式进行操作，操作过程中对于一些小规模的数组，可以先对其进行插入排序，因为对于子数组(长度小于15)的排序，插入排序的效率会更高一些，运行时间一般可以缩短10%到15%。</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  在merge之前先对数组进行判断是否已经有序，如果有序则直接跳过merge步骤</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!data[i+<span class="number">1</span>] &lt; data[i] ) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>快速排序同样属于一种分治算法，将一个数组分为两个子数组，然后将两部分进行独立的排序。</p>
<blockquote>
<p>和归并排序的区别：对于归并排序是先对独立的子数组进行排序，然后在将排序后的子数组进行归并而将整个数组进行排序。快速排序在将子数组排序之后，整体数组也同时完成了排序。</p>
</blockquote>
<p><img src="http://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort_b49af5.gif" alt="enter image description here"></p>
</li>
<li><p>步骤</p>
<ol>
<li>对数组进行shuffle，保证快速排序的性能</li>
<li>切分数组(需要满足如下条件)<ul>
<li>对于某个<code>j</code>, <code>a[j]</code>已经排定</li>
<li><code>a[low]</code>到<code>a[j-1]</code>的所有元素都不大于<code>a[j]</code></li>
<li><code>a[j+1]</code>到<code>a[high]</code>的所有元素都不小于<code>a[j]</code></li>
</ul>
</li>
<li>递归的对数组进行排序</li>
</ol>
</li>
<li><p>切分(Partition)</p>
<p>  切分操作一般都选择数组的第一个元素作为切分元素，下一步从数组的左侧向右扫描，直到发现大于切分元素即跳出扫描循环。另一部分从数组的右侧向左扫描，当发现小于切分元素即跳出第二个扫描循环。当扫描指针相遇的时候，跳出大循环。</p>
<p>  <img src="http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png" alt="enter image description here"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;<span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//从数组两侧进行扫描</span></div><div class="line">        <span class="keyword">while</span>(data[++i] &lt; compare) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;<span class="comment">//当左指针大于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">while</span> (compare &lt; data[--j]) <span class="keyword">if</span> (j == low) <span class="keyword">break</span>;<span class="comment">//当右指针小于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;<span class="comment">//当左右指针相遇的时候，跳出循环体</span></div><div class="line">        <span class="comment">//元素交换</span></div><div class="line">        temp = data[i];</div><div class="line">        data[i] = data[j];</div><div class="line">        data[j] = temp;</div><div class="line">    &#125;</div><div class="line">    temp = data[low];</div><div class="line">    data[low] = data[j];</div><div class="line">    data[j] = temp;</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">    <span class="comment">//将首元素和位置[j]的元素进行交换</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="改善快速排序性能的简单方法："><a href="#改善快速排序性能的简单方法：" class="headerlink" title="改善快速排序性能的简单方法："></a>改善快速排序性能的简单方法：</h4><ul>
<li>类似于归并排序，对于小数组，插入排序的效率更高一些</li>
<li>由于递归的原因，排序方法也会在小数组当中调用自己</li>
</ul>
<h4 id="三取样切分"><a href="#三取样切分" class="headerlink" title="三取样切分"></a>三取样切分</h4><p>通过使用子数组一部分元素的中位数来对数组进行切分。</p>
<h4 id="三向切分-熵最优排序"><a href="#三向切分-熵最优排序" class="headerlink" title="三向切分(熵最优排序)"></a>三向切分(熵最优排序)</h4><p>Ex:</p>
<p><img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort-3-way_d176ee.gif" alt="enter image description here"></p>
<p>该情况适用于数组当中存在大量重复元素的样例。当切分的元素重复的时候，不需要对其进行排序即可。切分的三部分分别为大于小于等于元素的数组元素</p>
<ul>
<li>data[i] &lt; compare元素 二者交换 i 和 lt同时增加</li>
<li>data[i] &gt; compare元素 和data[gt]交换 gt减少</li>
<li>data[i] = compare元素 i++</li>
</ul>
<p>这样的操作能够保证数组元素不变，同时缩小gt-i的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threeWaySort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>; <span class="comment">//递归结束条件</span></div><div class="line">    <span class="keyword">int</span> lt = low, i = low + <span class="number">1</span>, gt = high; <span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (i &lt;= gt)&#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[lt];</div><div class="line">            data[lt] = temp;</div><div class="line">            i++;</div><div class="line">            lt++;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[gt];</div><div class="line">            data[gt] = temp;</div><div class="line">            gt--;</div><div class="line">        &#125;<span class="keyword">else</span> i++;</div><div class="line">    &#125;</div><div class="line">    threeWaySort(data, low, lt-<span class="number">1</span>);</div><div class="line">    threeWaySort(data, gt+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Elementary Sorting]]></title>
      <url>http://yoursite.com/2016/11/28/Algorithm-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法的目的是将数组元素的主键依照某种方式进行排序。排序后索引较大的主键大于或等于索引较小的主键。</p>
<p>在java当中，元素通常都是对象，对主键的抽象描述是通过一种内部构建的机制来完成的(java中的Comparable接口)</p>
<h3 id="比较函数的性质"><a href="#比较函数的性质" class="headerlink" title="比较函数的性质"></a>比较函数的性质</h3><p>比较函数需要满足如下性质才能是的排序函数正常执行：</p>
<ol>
<li>反对称性：a &lt;= b且b &lt;= a推出a = b</li>
<li>传递性：a &lt;= b且b &lt;= c推出a &lt;= c</li>
<li>整体性：存在a &lt;= b或者b &lt;= a或者二者同时存在</li>
</ol>
<a id="more"></a>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><ul>
<li><p>less: 判断两个相比较的元素是否存在小于关系</p>
</li>
<li><p>exchange：交换比较数组中的元素</p>
</li>
<li><p>顺序检查： 检查排序的数组是否已经完成排序</p>
</li>
</ul>
<h3 id="Template-of-Sorting-Algorithm"><a href="#Template-of-Sorting-Algorithm" class="headerlink" title="Template of Sorting Algorithm"></a>Template of Sorting Algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">/* Code */</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> v.Comparable(w) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        Comparable t = a[i];</div><div class="line">        a[i] = a[j];</div><div class="line">        a[j] = t;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Print Array</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</div><div class="line">            System.out.println(a[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Test if the Array is sorted</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(less(a[i]), a[i-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String[] a = In.readString();</div><div class="line">        sort(a);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</div><div class="line">        show(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基本排序分类"><a href="#基本排序分类" class="headerlink" title="基本排序分类"></a>基本排序分类</h2><h3 id="冒泡排序-复杂度-O-n-2"><a href="#冒泡排序-复杂度-O-n-2" class="headerlink" title="冒泡排序(复杂度 O(n^2))"></a>冒泡排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/bubble-sort_ee720b.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  冒泡排序通过每次对需要排序的<code>item</code>的每一个相邻项进行比较，若前一个比后一个大，则进行交换。通过这个操作，每一趟排列可以将<code>item</code>中的最大值置于最高位，在经过<code>n-1</code>趟循环之后，排列结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="comment">//总共外部循环需要n-1次，每次迭代排序数组需要n-1次</span></div><div class="line">        <span class="comment">//同时需要考虑数据交换</span></div><div class="line">        <span class="comment">//冒泡排序每经过一次外层循环都可以把最高位归位</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=data.length-<span class="number">1</span>; j++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=data.length-<span class="number">1</span>-j; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (data[i-<span class="number">1</span>]&gt;data[i])&#123;</div><div class="line">                    temp = data[i-<span class="number">1</span>];</div><div class="line">                    data[i-<span class="number">1</span>] = data[i];</div><div class="line">                    data[i] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序-复杂度-O-n-2"><a href="#选择排序-复杂度-O-n-2" class="headerlink" title="选择排序(复杂度 O(n^2))"></a>选择排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/selection-sort_f03ab6.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  在数组中查询最小的元素，然后将其与数组中的第一个元素进行交换。当数组的第一个元素为最小元素的时候(将其与自身进行交换)。下一步在其余元素中找到最小的元素，将其与数组中的第二个元素进行交换。循环往复，直到将整个数组进行了排序。基本概念就是在剩余元素当中寻找最小者。</p>
</li>
<li><p>复杂度</p>
<p>  对于选择排序来说，当数组长度为<code>N</code>, 其大约需要<code>N^2/2</code>次比较与<code>N</code>次交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length-<span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="comment">//由于选择排序每经过一次外层循环，标记点的左侧为已完成排序的内容</span></div><div class="line">            <span class="keyword">int</span> min = i;<span class="comment">//设置初始标记点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; data.length; j++) &#123;</div><div class="line">                <span class="comment">//内层循环用于和标记点进行比较</span></div><div class="line">                <span class="keyword">if</span> (data[min] &gt; data[j])&#123;</div><div class="line">                    min = j;<span class="comment">//如果小于标记点，便替换标记点，当内层循环结束后，定位了此轮循环最小值的位置，跳出循环后将其</span></div><div class="line">                    <span class="comment">//初始标记点进行替换即可</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进行交换</span></div><div class="line">            <span class="keyword">int</span> temp = data[i];</div><div class="line">            data[i] = data[min];</div><div class="line">            data[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序-复杂度-O-n-2"><a href="#插入排序-复杂度-O-n-2" class="headerlink" title="插入排序(复杂度 O(n^2))"></a>插入排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="http://img.blog.csdn.net/20140602175214796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  插入排序通过对索引左侧的数据进行不断的排列，使得索引左侧的数据保持有序，同时用未排序的数字和已排序的队列进行比较，当比它大，则进行交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.length; i++)&#123;</div><div class="line">            <span class="comment">//内部循环是为了进行将对应指针左侧进行排列，并将较大的数字向右移动</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="keyword">if</span> (data[j]&lt;data[j-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = data[j-<span class="number">1</span>];</div><div class="line">                    data[j-<span class="number">1</span>] = data[j];</div><div class="line">                    data[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序-复杂度介于O-nlogn到n-2"><a href="#希尔排序-复杂度介于O-nlogn到n-2" class="headerlink" title="希尔排序 复杂度介于O(nlogn到n^2)"></a>希尔排序 复杂度介于O(nlogn到n^2)</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/shell-sort_5c15b3.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念<br>  希尔排序是对于插入排序的一种优化，插入排序当数值较小的<code>key</code>排在靠后的位置时，排序的效率是比较低的，因为在应用插入排序的时候，它只会交换相邻元素。<br>  希尔排序通过交换不相邻元素的位置，使得较小的值能够被更快地移动到开头位置，其应用思想被称为<code>h</code>有序数组。<br>  <img src="http://algs4.cs.princeton.edu/21elementary/images/h-sorted.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &lt;= data.length) step = <span class="number">3</span>*step + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &gt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//此步先对外部循环进行判断，即每次step需要的运行次数</span></div><div class="line">            <span class="comment">//此处外部循环导致越界，尤其在数组边界的时候</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= step; j -= step)&#123;</div><div class="line">                    <span class="comment">//在交换时候考虑超过数组边界问题</span></div><div class="line">                    <span class="keyword">if</span> (data[j-step] &gt; data[j])&#123;</div><div class="line">                        <span class="keyword">int</span> temp = data[j-step];</div><div class="line">                        data[j-step] = data[j];</div><div class="line">                        data[j] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            step = step/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/21elementary/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Data Structure-Stack]]></title>
      <url>http://yoursite.com/2016/11/24/Data%20Structure-Stack/</url>
      <content type="html"><![CDATA[<h2 id="Data-Structure-Princeton-Algorithm"><a href="#Data-Structure-Princeton-Algorithm" class="headerlink" title="Data Structure-Princeton Algorithm"></a>Data Structure-Princeton Algorithm</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><h4 id="Basic-API-of-Stack"><a href="#Basic-API-of-Stack" class="headerlink" title="Basic API of Stack"></a>Basic API of Stack</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;</span></div><div class="line"></div><div class="line"><span class="title">Stack</span><span class="params">()</span> <span class="comment">//创建空栈</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> <span class="comment">//向栈中添加元素</span></div><div class="line"></div><div class="line">Item <span class="title">pop</span><span class="params">()</span> <span class="comment">//从栈中删除最近添加元素</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 检测栈是否为空</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="comment">//栈中包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="Stack的实现方式"><a href="#Stack的实现方式" class="headerlink" title="Stack的实现方式"></a>Stack的实现方式</h2><ul>
<li><p>Linked_list</p>
<blockquote>
<p>定义： 链表是一种递归的数据结构，它可以为空(null)，也可以指向对一个节点的(node)的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。 结点可作为任意数据类型的抽象实体。</p>
</blockquote>
</li>
</ul>
<h3 id="Stack的linkedlist-实现"><a href="#Stack的linkedlist-实现" class="headerlink" title="Stack的linkedlist 实现"></a>Stack的linkedlist 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">inner <span class="class"><span class="keyword">class</span></span></div><div class="line"><span class="title">private</span> <span class="title">class</span> <span class="title">Node</span>&#123;</div><div class="line">    String item;</div><div class="line">    Node next;</div><div class="line">&#125;</div><div class="line"><span class="comment">//对节点进行初始化</span></div></pre></td></tr></table></figure>
<ul>
<li><p>Push 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-insert-front.png" alt="enter image description here"></p>
</li>
<li><p>Pop 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-remove-first.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;<span class="comment">// Initialize the first node of the linkedlist</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//number of items</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        String item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// or N == 0;</span></div><div class="line">        <span class="comment">//judge if the stack is empty</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</div><div class="line">        Node oldfirst = first;</div><div class="line">        <span class="comment">//将当前的首位赋值给临时的oldfirst</span></div><div class="line">        first = <span class="keyword">new</span> Node();</div><div class="line">        first.item = item;</div><div class="line">        <span class="comment">//将压入stack的item复制给新的first</span></div><div class="line">        first.next = oldfirst;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        String item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Stack的Resizing-Array实现"><a href="#Stack的Resizing-Array实现" class="headerlink" title="Stack的Resizing Array实现"></a>Stack的Resizing Array实现</h3><ul>
<li>Array<blockquote>
<p>关于定容数组对于栈的实现, 在初始化栈的时候，必须要先设定栈的最大容量。同时数组一旦被创建，其大小便无法进行改变。当数组容量被设置过大的时候，又会浪费大量的内存。然而在用例过大的时候，也会很容易发生溢出问题，因此实现栈容量的动态调节是非常有必要的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizingArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];<span class="comment">// java不支持泛型数组，所以需要进行强制转换</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</div><div class="line">        <span class="comment">//将stack移动到大小为max的数组当中</span></div><div class="line">        Item[] temp = (Item[]) <span class="keyword">new</span> Object[max];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            temp[i] = a[i];</div><div class="line">        &#125;</div><div class="line">        a = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (N == a.length) &#123;</div><div class="line">            resize(<span class="number">2</span>*a.length);</div><div class="line">            a[N++] = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        Item item = a[--N];</div><div class="line">        a[N] = <span class="keyword">null</span>;<span class="comment">//避免对象游离，成为“孤儿”</span></div><div class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N == a.length/<span class="number">4</span>) &#123;</div><div class="line">            resize(a.length/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseArrayIterator();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = N;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a[--i];&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对象游离<blockquote>
<p>java的GC策略是将所有无法被访问的对象的内存， 在上述Pop操作的代码当中，被弹出的元素的引用仍旧存在于数组当中。但是这个元素实际上已经成为一个“孤儿”， 即它永远不会再被访问了。 除非这个引用被覆盖，否则java的GC机制永远无法知道这点。因此为了避免出现这种现象，我们需要将弹出的元素设置为null，则这个用例可正常被作为垃圾进行回收。</p>
</blockquote>
</li>
</ul>
<h2 id="上述两种方式的比较"><a href="#上述两种方式的比较" class="headerlink" title="上述两种方式的比较"></a>上述两种方式的比较</h2><ul>
<li>Linkedlist<ul>
<li>最差情况下，每一步操作都要消耗恒定时间</li>
<li>需要花费额外的时间和空间对链接进行处理</li>
</ul>
</li>
<li>Resizing-Array<ul>
<li>每一步操作都需要花费平均的摊销时间</li>
<li>消耗更少量的空间</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/13stacks/" target="_blank" rel="external">Princeton-Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Union Find]]></title>
      <url>http://yoursite.com/2016/11/12/Union-Find-Algorithm/</url>
      <content type="html"><![CDATA[<h2 id="Princeton-Algorithm"><a href="#Princeton-Algorithm" class="headerlink" title="Princeton - Algorithm"></a>Princeton - Algorithm</h2><p>1st week：Union-Find</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有N个元素，从0~N-1编号，假如两个元素之间的连接视为通路，当执行多次任意的两个元素之间的连接之后，如何判断两个元素能够经由已有路径相连通。对于连接的动作称为union，判断是否连接的操作称为find，如下图<br><a id="more"></a><br><img src="http://obpbs8a3y.bkt.clouddn.com/1.jpg" alt="enter image description here"><br><img src="http://img.blog.csdn.net/20130901114328078" alt="enter image description here"></p>
<p>从上图中可以看出，0, 1, 2, 5, 6, 7 中的任意两个元素都是相连的，同样 3, 4, 8, 9 中任意两个元素也是互连的，但是第一个集合和第二个集合的元素却是无法连通的。</p>
<p>实际操作中可用于在一个庞大的网路环境下，如何迅速判断某两个点是否相连，如下图：</p>
<p><img src="http://i2.piimg.com/567571/38bfecc955fdf85c.jpg" alt="enter image description here"></p>
<h3 id="有效算法的开发步骤"><a href="#有效算法的开发步骤" class="headerlink" title="有效算法的开发步骤"></a>有效算法的开发步骤</h3><ol>
<li>构建需求模型</li>
<li>寻找所需算法</li>
<li>运行算法检测速度和内存是否符合要求</li>
<li>效率差或者达不到要求，找出问题的原因</li>
<li>寻求解决办法，循环上述步骤直到满意为止</li>
</ol>
<h3 id="首先确认Union和Find操作应该满足怎样的条件："><a href="#首先确认Union和Find操作应该满足怎样的条件：" class="headerlink" title="首先确认Union和Find操作应该满足怎样的条件："></a>首先确认Union和Find操作应该满足怎样的条件：</h3><p>find操作：确认两个对象是否连接：<br>自反性：P连接到Q<br>对称性：P连接到Q，则 Q连接到P<br>传递性：P连接到Q，Q连接到R，则P也连接到R</p>
<p>union操作：连接在一起的对象，我们统称为一个连接集合，执行一次union操作就相当于将两个对象所在的集合连接到一起，组成一个新的集合。新集合中的任意两个成员也应该都处于连接状态。</p>
<h3 id="Connected-Component"><a href="#Connected-Component" class="headerlink" title="Connected Component"></a>Connected Component</h3><p>Concept: 相连的节点所构成的集合</p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>并查集提供了两种操作：</p>
<ol>
<li>查找操作(find)：检测两个节点是否相连</li>
<li>合并操作(Union): 将两节点进行链接</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>并查集算法需要实现如下目标：</p>
<ol>
<li>查找对象的数量N可以非常大</li>
<li>操作的次数M可以非常大</li>
<li>Find和Union操作可以随意调用</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>数据结构<br>假设有N个节点，该算法的数据结构为一个包含N个整数的数组id[]</p>
<h3 id="Find操作"><a href="#Find操作" class="headerlink" title="Find操作"></a>Find操作</h3><p>判断p q两个节点是否相连，通过判断id[p]和id[q]对应的数值是否一致</p>
<h3 id="Union操作"><a href="#Union操作" class="headerlink" title="Union操作"></a>Union操作</h3><p>将两节点合作是通过将被合并的节点q的id值设为节点p的id值</p>
<p>但是合并操作的缺点是在进行Union操作的时候，需要遍历整个数组，因此算法开销比较大</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>每一次合并的复杂度为N，当合并次数非常大的时候，趋近于N，运算的复杂度则为N^2,因此该算法不适合较大规模运算。</p>
<p>查找操作的复杂度为1.</p>
<h2 id="Quick-Union-Lazy-Approach"><a href="#Quick-Union-Lazy-Approach" class="headerlink" title="Quick Union(Lazy Approach)"></a>Quick Union(Lazy Approach)</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>整型数组id[],大小为N</li>
<li>Interpretation: 数组的每个元素id[i]指的是i的上一级为id[i]</li>
<li>i的根节点 id[id[id[…id[]…]]]</li>
</ol>
<h3 id="Find操作-1"><a href="#Find操作-1" class="headerlink" title="Find操作"></a>Find操作</h3><p>如果P和Q两个值对应相同的根节点，则为找到</p>
<h3 id="Union操作-1"><a href="#Union操作-1" class="headerlink" title="Union操作"></a>Union操作</h3><p>如果需要将p q进行连接，则需要将二者对应的根节点数设为相同值</p>
<p><img src="http://img.blog.csdn.net/20130901134321640" alt="enter image description here"></p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>在最坏的情况下，查找操作的复杂度仍将达到N</p>
<h2 id="Quick-Union的优化"><a href="#Quick-Union的优化" class="headerlink" title="Quick Union的优化"></a>Quick Union的优化</h2><p>通过每个节点增加quality的概念，使得quality小的component位于大的component之下，从而避免了树形结构过高的问题。</p>
<p>如下图展示了树形结构深度优化后的效果<br><img src="http://img.blog.csdn.net/20140602174057171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>合并操作的最坏复杂度为lgN,查询操作的最坏复杂度为lgN</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>在查找根节点时，将路径上的所有节点进行路径压缩，理论上得到的find操作的复杂度为1.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HotKey of Intellij IDEA]]></title>
      <url>http://yoursite.com/2016/01/17/HotKey%20of%20Intellij%20IDEA/</url>
      <content type="html"><![CDATA[<p><em>Intellij IDEA作为一款能力非常强大的集成开发工具，为日常的程序开发带来了很大的便利，同时内部自带的快捷键也极大地提升了开发效率，本文将主要对Intellij IDEA中的常用快捷键进行总结</em><br><a id="more"></a></p>
<h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">Ctrl+E，最近的文件</div><div class="line">Ctrl+Shift+E，最近更改的文件</div><div class="line">Shift+Click，可以关闭文件</div><div class="line">Ctrl+[ OR ]，可以跑到大括号的开头与结尾</div><div class="line">Ctrl+F12，可以显示当前文件的结构</div><div class="line">Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择</div><div class="line">Ctrl+N，可以快速打开类</div><div class="line">Ctrl+Shift+N，可以快速打开文件</div><div class="line">Alt+Q，可以看到当前方法的声明</div><div class="line">Ctrl+P，可以显示参数信息</div><div class="line">Ctrl+Shift+Insert，可以选择剪贴板内容并插入</div><div class="line">Alt+Insert，可以生成构造器/Getter/Setter等</div><div class="line">Ctrl+Alt+V，可以引入变量。例如：new String();  自动导入变量定义</div><div class="line">Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch</div><div class="line">Ctrl+Enter，导入包，自动修正</div><div class="line">Ctrl+Alt+L，格式化代码</div><div class="line">Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作</div><div class="line">Ctrl+Alt+O，优化导入的类和包</div><div class="line">Ctrl+R，替换文本</div><div class="line">Ctrl+F，查找文本</div><div class="line">Ctrl+Shift+Space，自动补全代码</div><div class="line">Ctrl+空格，代码提示（与系统输入法快捷键冲突）</div><div class="line">Ctrl+Shift+Alt+N，查找类中的方法或变量</div><div class="line">Alt+Shift+C，最近的更改</div><div class="line">Alt+Shift+Up/Down，上/下移一行</div><div class="line">Shift+F6，重构 - 重命名</div><div class="line">Ctrl+X，删除行</div><div class="line">Ctrl+D，复制行</div><div class="line">Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）</div><div class="line">Ctrl+J，自动代码（例如：serr）</div><div class="line">Ctrl+Alt+J，用动态模板环绕</div><div class="line">Ctrl+H，显示类结构图（类的继承层次）</div><div class="line">Ctrl+Q，显示注释文档</div><div class="line">Alt+F1，查找代码所在位置</div><div class="line">Alt+1，快速打开或隐藏工程面板</div><div class="line">Ctrl+Alt+left/right，返回至上次浏览的位置</div><div class="line">Alt+left/right，切换代码视图</div><div class="line">Alt+Up/Down，在方法间快速移动定位</div><div class="line">Ctrl+Shift+Up/Down，向上/下移动语句</div><div class="line">F2 或 Shift+F2，高亮错误或警告快速定位</div><div class="line">Tab，代码标签输入完成后，按 Tab，生成代码</div><div class="line">Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失</div><div class="line">Alt+F3，逐个往下查找相同文本，并高亮显示</div><div class="line">Ctrl+Up/Down，光标中转到第一行或最后一行下</div><div class="line">Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）</div><div class="line">Ctrl+Alt+B，跳转到方法实现处</div><div class="line">Ctrl+Shift+Backspace，跳转到上次编辑的地方</div><div class="line">Ctrl+O，重写方法</div><div class="line">Ctrl+Alt+Space，类名自动完成</div><div class="line">Ctrl+Alt+Up/Down，快速跳转搜索结果</div><div class="line">Ctrl+Shift+J，整合两行</div><div class="line">Alt+F8，计算变量值</div><div class="line">Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本</div><div class="line">Ctrl+Alt+Shift+V，简单粘贴</div><div class="line">Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口</div><div class="line">F12，把焦点从编辑器移到最近使用的工具窗口</div><div class="line">Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器</div><div class="line">Ctrl+W，可以选择单词继而语句继而行继而函数</div><div class="line">Ctrl+Shift+W，取消选择光标所在词</div><div class="line">Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置</div><div class="line">Ctrl+I，实现方法</div><div class="line">Ctrl+Shift+U，大小写转化</div><div class="line">Ctrl+Y，删除当前行</div><div class="line">Shift+Enter，向下插入新行</div><div class="line">psvm/sout，main/System.out.println(); Ctrl+J，查看更多</div><div class="line">Ctrl+Shift+F，全局查找</div><div class="line">Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找</div><div class="line">Ctrl+Shift+S，高级搜索</div><div class="line">Ctrl+U，转到父类</div><div class="line">Ctrl+Alt+S，打开设置对话框</div><div class="line">Alt+Shift+Inert，开启/关闭列选择模式</div><div class="line">Ctrl+Alt+Shift+S，打开当前项目/模块属性</div><div class="line">Ctrl+G，定位行</div><div class="line">Alt+Home，跳转到导航栏</div><div class="line">Ctrl+Enter，上插一行</div><div class="line">Ctrl+Backspace，按单词删除</div><div class="line">Ctrl+&quot;+/-&quot;，当前方法展开、折叠</div><div class="line">Ctrl+Shift+&quot;+/-&quot;，全部展开、折叠</div></pre></td></tr></table></figure>
<h3 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="调试部分、编译"></a>调试部分、编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Ctrl+F2，停止</div><div class="line">Alt+Shift+F9，选择 Debug</div><div class="line">Alt+Shift+F10，选择 Run</div><div class="line">Ctrl+Shift+F9，编译</div><div class="line">Ctrl+Shift+F10，运行</div><div class="line">Ctrl+Shift+F8，查看断点</div><div class="line">F8，步过</div><div class="line">F7，步入</div><div class="line">Shift+F7，智能步入</div><div class="line">Shift+F8，步出</div><div class="line">Alt+Shift+F8，强制步过</div><div class="line">Alt+Shift+F7，强制步入</div><div class="line">Alt+F9，运行至光标处</div><div class="line">Ctrl+Alt+F9，强制运行至光标处</div><div class="line">F9，恢复程序</div><div class="line">Alt+F10，定位到断点</div><div class="line">Ctrl+F8，切换行断点</div><div class="line">Ctrl+F9，生成项目</div><div class="line">Alt+1，项目</div><div class="line">Alt+2，收藏</div><div class="line">Alt+6，TODO</div><div class="line">Alt+7，结构</div><div class="line">Ctrl+Shift+C，复制路径</div><div class="line">Ctrl+Alt+Shift+C，复制引用，必须选择类名</div><div class="line">Ctrl+Alt+Y，同步</div><div class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</div><div class="line">Shift+F12，还原默认布局</div><div class="line">Ctrl+Shift+F12，隐藏/恢复所有窗口</div><div class="line">Ctrl+F4，关闭</div><div class="line">Ctrl+Shift+F4，关闭活动选项卡</div><div class="line">Ctrl+Tab，转到下一个拆分器</div><div class="line">Ctrl+Shift+Tab，转到上一个拆分器</div></pre></td></tr></table></figure>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ctrl+Alt+Shift+T，弹出重构菜单</div><div class="line">Shift+F6，重命名</div><div class="line">F6，移动</div><div class="line">F5，复制</div><div class="line">Alt+Delete，安全删除</div><div class="line">Ctrl+Alt+N，内联</div></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Ctrl+F，查找</div><div class="line">Ctrl+R，替换</div><div class="line">F3，查找下一个</div><div class="line">Shift+F3，查找上一个</div><div class="line">Ctrl+Shift+F，在路径中查找</div><div class="line">Ctrl+Shift+R，在路径中替换</div><div class="line">Ctrl+Shift+S，搜索结构</div><div class="line">Ctrl+Shift+M，替换结构</div><div class="line">Alt+F7，查找用法</div><div class="line">Ctrl+Alt+F7，显示用法</div><div class="line">Ctrl+F7，在文件中查找用法</div><div class="line">Ctrl+Shift+F7，在文件中高亮显示用法</div></pre></td></tr></table></figure>
<h3 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alt+~，VCS 操作菜单</div><div class="line">Ctrl+K，提交更改</div><div class="line">Ctrl+T，更新项目</div><div class="line">Ctrl+Alt+Shift+D，显示变化</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
