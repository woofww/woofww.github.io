<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Design Pattern-Singleton]]></title>
      <url>http://yoursite.com/2016/12/22/Design%20Pattern-Singleton/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在软件工程当中，设计模式 (Design Pattern) 是对软件设计当中普遍存在的各种问题，所得出的解决方案。设计模式并不是直接用来完成代码的编写，而是描述在不同的状况下，要如何解决问题的一种方案。<br><a id="more"></a><br>面向对象设计模式通常以类别或者对象来描述其中的关系和相互作用， 但不涉及用来完成应用程序的特定类别或者对象。设计模式能使不稳定依赖于相对稳定，具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。本系列文章将主要着重于介绍Android开发中几个常用的设计模式进行介绍和探讨。<br><a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="external">—Wikipedia</a></p>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>在应用单例模式的时候，单例对象的类必须保证只有一个实例存在。 在很多情况下，整个系统只需要拥有一个全局对象，这样更有利于对系统整体的行为进行协调。比如在服务器程序当中，该服务器的配置信息存放在一个文件当中，这些服务器的配置便由一个单例对象进行统一的读取，然后服务器中的其他对象在通过这个单例对象进行配置信息的获取，这样便简化了配置管理的环境。</p>
</blockquote>
<ul>
<li><img src="http://s9.sinaimg.cn/mw690/674f4fc6gddd1e4334838&amp;690" alt=""></li>
</ul>
<blockquote>
<p>特点:</p>
<p>A:单例模式只能存在一个实例；</p>
<p>B:单利模式类必须自己创建自己的唯一实例；</p>
<p>C:单利模式类必须给其他所有对象提供这个实例</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>懒汉单例模式</p>
<p> 第一次对单例对象进行实例化的时候，当处于并发环境的时候，可能会出现多个单例本身对象，这样就是线程不安全的。</p>
</li>
<li><p>饿汉单例模式</p>
<p> 在单例类进行初始化的时候，已经自行实例化一个静态对象，本身便是线程安全的。</p>
</li>
<li><p>登记单例模式</p>
<p> 通过一个专门的类对各个单例模式的单一实例进行管理和维护</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/*当单例为空的时候进行创建，否则直接返回，保证唯一性*/</span></div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*线程安全的懒汉单例模式*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="function">publci <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Searching]]></title>
      <url>http://yoursite.com/2016/12/19/Algorithm-Searching/</url>
      <content type="html"><![CDATA[<h2 id="Symbol-Table-符号表"><a href="#Symbol-Table-符号表" class="headerlink" title="Symbol Table (符号表)"></a>Symbol Table (符号表)</h2><blockquote>
<p>定义： 符号表是一种可以存储<code>key-value</code>的数据结构，它可以进行两种操作，<code>put</code>(将键值对存入符号表)和<code>get</code>操作(根据给定的<code>key</code>查找<code>value</code>)，就相当于字典查询一样，需要通过索引进行对应查找</p>
</blockquote>
<a id="more"></a>
<h3 id="Base-API"><a href="#Base-API" class="headerlink" title="Base API"></a>Base API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class SymbolTable&lt;key,value&gt;</span></div><div class="line"><span class="title">SymbolTable</span><span class="params">()</span>                创建ST</div><div class="line"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> 将键值对存入表当中</div><div class="line">Value <span class="title">get</span><span class="params">(Key key)</span>           根据Key查找value</div><div class="line"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>         从表当中删除key</div><div class="line"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span>    键值key在表当中是否存在对应值</div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>            判断表是否为空</div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                   判断表的容量</div><div class="line">Iterable&lt;key&gt; <span class="title">keys</span><span class="params">()</span>         表当中所有键值对的集合</div></pre></td></tr></table></figure>
<h3 id="基于无序链表的顺序查找"><a href="#基于无序链表的顺序查找" class="headerlink" title="基于无序链表的顺序查找"></a>基于无序链表的顺序查找</h3><blockquote>
<p>将链表应用于符号表是通过每个节点存储<code>key-value</code>对，同时通过<code>get()</code>方法遍历链表，当被查找的<code>key</code>和结点所对应的<code>key</code>完全一致时，则返回对应结点的数值，否则返回<code>null</code>。<code>put()</code>方法的实现同样是通过遍历链表，当被查找的<code>key</code>和结点当中存储的完全一致是，则将第二个参数<code>value</code>的值更新结点位置的数值。</p>
</blockquote>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/sequential-search.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;</div><div class="line">    privagte <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Key key;</div><div class="line">        Value value;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function">publci <span class="title">Node</span><span class="params">(Key key, Value value, Node next)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">        <span class="comment">//查找部分，根据给定的key，查找对应value，不存在返回null</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                <span class="keyword">return</span> x.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">        <span class="comment">//插入部分，根据给定的key，如果找到，更新其value，未找到则new出新的结点</span></div><div class="line">        <span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (key.equals(x.key)) &#123;</div><div class="line">                x.value = value;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        first = <span class="keyword">new</span> Node(key, value, first);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于有序数组的二分查找"><a href="#基于有序数组的二分查找" class="headerlink" title="基于有序数组的二分查找"></a>基于有序数组的二分查找</h3><blockquote>
<p>通过应用一对平行数组，利用其中一个存储<code>key</code>一个存储<code>value</code>，从而实现高效的索引以及其他操作。<br>这部分的核心是实现<code>rank()</code>方法，该方法可以返回<code>table</code>当中小于给定<code>value</code>的数量，对于<code>get()</code>方法，当给定的<code>key</code>存在于表当中的时候，<code>rank()</code>方法便能够通知该<code>key</code>的位置。对于<code>put()</code>方法，<code>rank</code>方法可以确定<code>value</code>的更新位置。</p>
</blockquote>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p><img src="http://algs4.cs.princeton.edu/31elementary/images/binary-search.png" alt="enter image description here"></p>
<p>二分查找算法当中存在一个<code>rank()</code>函数，用于返回查询键值的位置，当表中存在该键的时候，返回值表示<code>table</code>当中小于他的键的数量。如果表当中不存在改键，<code>rank()</code>同样返回表当中小于它的键的数目。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (isEmpty()) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">    <span class="keyword">int</span> i = rank(key);<span class="comment">//找到key在数组中对应的位置</span></div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; key[i] == key) &#123;</div><div class="line">        <span class="keyword">return</span> values[i];</div><div class="line">        <span class="comment">//N为数组大小，如果key和数组当中对应位置的i匹配，返回其对应值</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = rank(key);</div><div class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i] == key) &#123;</div><div class="line">        values[i] = value;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建新元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j-- ) &#123;</div><div class="line">        keys[j] = keys[j-<span class="number">1</span>];</div><div class="line">        values[j] = values[j-<span class="number">1</span>];</div><div class="line">    &#125;<span class="comment">//用于对位置i进行置空,将大于i的元素向后移动</span></div><div class="line">    keys[i] = key;</div><div class="line">    values[i] = value;</div><div class="line">    N++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt; low) &#123; <span class="keyword">return</span> low;&#125;</div><div class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">    <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, low, mid-<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> rank(key, mid+<span class="number">1</span>, high);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">&#125;</div><div class="line"><span class="comment">//迭代</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = N-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>( low &lt;= high)&#123;</div><div class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> compare = key - keys[mid];</div><div class="line">        <span class="keyword">if</span> (compare &lt; <span class="number">0</span>) <span class="keyword">return</span> high = mid - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compare &gt; <span class="number">0</span>) <span class="keyword">return</span> low = mid + <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Binary-Search-Tree-二叉查找树"><a href="#Binary-Search-Tree-二叉查找树" class="headerlink" title="Binary Search Tree (二叉查找树)"></a>Binary Search Tree (二叉查找树)</h2><blockquote>
<p>以上提到的链表的顺序查找以及二分查找均不能同时在查找和插入两个方面很好的完成工作。 二叉树的数据结构能很好的兼顾这两方面。二叉树查找的每个节点均包含两个值，分别为键以及相关联的数值。同时二叉树的左子节点的数值也小于右子节点的数值。</p>
</blockquote>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320221749.jpg" alt="enter image description here"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>当二叉树为空时，查找对应未命中；当被查找的键和根结点的键对应的时候，即为查找命中。否则便递归地在子树当中进行查找，如果被查找的键比较小，选择左子树，否则便选择右子树。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1fayquslvw0j30f20avjte.jpg" alt=""></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当查找一个不存在于树当中的节点并且查找结束于一条空链接的时候，需要将链接指向一个含有被查找的键的新结点的位置。简而言之，当树为空，但会含有被查找键值对的新节点；当被查找的键小于根节点的键时，在左子树插入，否则在右子树插入。</p>
<p><img src="http://algs4.cs.princeton.edu/32bst/images/bst-insert.png" alt=""></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>Binary Search的算法的查找和插入运行时间在平均情况下都可以达到O(logn)。当时这个时间复杂度在很大程度上会受到树的形状的影响，同时树的形状又取决于键值被插入的先后顺序。</p>
<p>最好的情况系啊，一棵含有N个结点的树是完全平衡的，每条空连接到其根结点的距离都为logN。但是在最坏的情况下，搜索的路径上可能含有N个节点</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320222706.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySerach</span></span>&#123;</div><div class="line">    to be update</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Balanced-Search-Tree-平衡查找树"><a href="#Balanced-Search-Tree-平衡查找树" class="headerlink" title="Balanced Search Tree (平衡查找树)"></a>Balanced Search Tree (平衡查找树)</h2><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><blockquote>
<p>前面提到的几个搜索算法在最坏的情况下的性能依然不能令人满意。因此非常需要一个算法能够在查找和插入过程中都能保证很好的性能。这部分介绍的平衡搜索树能很好的解决这个问题。</p>
<p>在理想情况下，平衡查找树都能保证运行时间是对数级别的。对于一个含有N个节点的树当中，树的高度可以保证为lgN。这样便可以保证查找可以在lgN次内结束。</p>
</blockquote>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li><p>2-3树当中的2结点，含有一个<code>key</code>以及两条链接，左链接对应的<code>key</code>都小于父结点，右链接对应的<code>key</code>都大于父结点。</p>
</li>
<li><p>2-3树当中的3结点，含有两个<code>key</code>以及三条链接，左链接<br>对应的<code>key</code>都大于该结点，右链接对应的<code>key</code>都小于该结点，，中间链接对应的结点处于该结点两个<code>key</code>的中间。</p>
</li>
</ol>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320225636.jpg" alt=""></p>
<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>判断<code>key</code>是否在2-3树当中，先将<code>key</code>和结点的<code>key</code>进行比较，如果相等则查找成功。如果未找到，则继续根据情况在子链接当中递归的进行查找。如果最终为空连接，查找未命中。</p>
<p><img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-search.png" alt=""></p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><ul>
<li><p>向2-结点当中插入新键</p>
<p>  当插入操作结束于一个2-结点的时候，直接将2-结点替换为一个3-结点，便可以让树继续保持平衡。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png" alt=""></p>
</li>
<li><p>向只含有3-结点的树插入新键</p>
<p>  当一棵树当中只含有3-结点的时候，先临时将新键存入当前结点，构成一个4-结点。在这个情况下，很容易将其转化为一棵由3个2-结点组成的2-3树。</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png" alt=""></p>
</li>
<li><p>向父结点为2-结点的3-结点插入新键</p>
<p>  对于此种情况，可以先构造一个4-结点，下一步操作并不是为中键创建新结点，而是将中键上移到父结点的位置，这样便使得空连接到达根节点的距离依然是相同的</p>
<p>  <img src="http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png" alt=""></p>
<p>  类似的对于父结点为3-结点的三结点插入的时候，需要将中键不断上移，直至父节点不需要继续分解。</p>
</li>
</ul>
<h3 id="红黑二叉查找树"><a href="#红黑二叉查找树" class="headerlink" title="红黑二叉查找树"></a>红黑二叉查找树</h3><h4 id="待更。。。。。。"><a href="#待更。。。。。。" class="headerlink" title="待更。。。。。。"></a>待更。。。。。。</h4><h2 id="Hash-Table-哈希表"><a href="#Hash-Table-哈希表" class="headerlink" title="Hash Table (哈希表)"></a>Hash Table (哈希表)</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Advanced Sorting]]></title>
      <url>http://yoursite.com/2016/12/07/Algorithm-Advanced-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>对于归并的概念，简而言之就是分治，对于独立的部分单独地进行排序然后再将排序完成的子数组进行合并，最终完成全部排序。但是归并排序由于需要额外数组，所以空间复杂度也比较高。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/merge-sort_8993d8.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h4><ul>
<li><p>Example:</p>
<p>  <img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt="enter image description here"></p>
</li>
<li><p>原地归并为直接将两个不同的有序数组合并到第三个数组当中，当然该数组最终是有序的。原理：首先将原数组存放至一个临时数组当中，并通过指定参数如i和j指向数组的起始位置<code>low</code>和中间位置<code>middle</code>。以此保证了原数组左右两边是有序的。从左右两个独立数组的头部开始扫描数组，此时对<code>array[i]</code>和<code>array[j]</code>进行比较，将较大值放入临时数组。</p>
</li>
</ul>
<ul>
<li>抽象地描述便是<code>merge(a, low, middle, high)</code>，该方法会将<code>a[low..middle]</code>，<code>a[middle..high]</code>归并为一个有序的数组并将结果存放在<code>a[low..high]</code>当中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> middle, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data_new = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</div><div class="line">        <span class="keyword">int</span> left = low, right = middle+<span class="number">1</span>; <span class="comment">// 定义双指针</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= data.length-<span class="number">1</span> ; i++ ) &#123;</div><div class="line">            data_new[i] = data[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= high; i++ ) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt; middle) data[i] = data_new[right++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high ) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data_new[left] &lt; data_new[right]) data[i] = data_new[left++];</div><div class="line">            <span class="keyword">else</span> data[i] = data_new[right++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h4><p>自顶向下排序实现了一种递归归并的方法， 实现了一种典型的分治思想，运用迭代的思想将两个独立的子数组进行排序，并最终完成归并；对于一个长度为N的任意数组， 自顶向下归并排序需要进行1/2NloN到NlgN的比较</p>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;<span class="comment">//此种情况结束递归，即无法再继续进行分割</span></div><div class="line">    <span class="keyword">int</span> middle = low + (high - low)/<span class="number">2</span>;</div><div class="line">    sort(data, low, middle);<span class="comment">//对数组左半部分进行排序</span></div><div class="line">    sort(data, middle+<span class="number">1</span>, high);<span class="comment">//对右半部份进行排序</span></div><div class="line">    merge(data, low, middle, high);<span class="comment">//不断进行递归，直到无法继续进行直到结束</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h5><ul>
<li><p>对于规模较小的子数组使用插入排序</p>
<p>由于归并排序中频繁的使用了递归的方式进行操作，操作过程中对于一些小规模的数组，可以先对其进行插入排序，因为对于子数组(长度小于15)的排序，插入排序的效率会更高一些，运行时间一般可以缩短10%到15%。</p>
</li>
<li><p>测试数组是否已经有序</p>
<p>  在merge之前先对数组进行判断是否已经有序，如果有序则直接跳过merge步骤</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!data[i+<span class="number">1</span>] &lt; data[i] ) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>复杂度(nlogn)</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>快速排序同样属于一种分治算法，将一个数组分为两个子数组，然后将两部分进行独立的排序。</p>
<blockquote>
<p>和归并排序的区别：对于归并排序是先对独立的子数组进行排序，然后在将排序后的子数组进行归并而将整个数组进行排序。快速排序在将子数组排序之后，整体数组也同时完成了排序。</p>
</blockquote>
<p><img src="http://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png" alt="enter image description here"></p>
<ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort_b49af5.gif" alt="enter image description here"></p>
</li>
<li><p>步骤</p>
<ol>
<li>对数组进行shuffle，保证快速排序的性能</li>
<li>切分数组(需要满足如下条件)<ul>
<li>对于某个<code>j</code>, <code>a[j]</code>已经排定</li>
<li><code>a[low]</code>到<code>a[j-1]</code>的所有元素都不大于<code>a[j]</code></li>
<li><code>a[j+1]</code>到<code>a[high]</code>的所有元素都不小于<code>a[j]</code></li>
</ul>
</li>
<li>递归的对数组进行排序</li>
</ol>
</li>
<li><p>切分(Partition)</p>
<p>  切分操作一般都选择数组的第一个元素作为切分元素，下一步从数组的左侧向右扫描，直到发现大于切分元素即跳出扫描循环。另一部分从数组的右侧向左扫描，当发现小于切分元素即跳出第二个扫描循环。当扫描指针相遇的时候，跳出大循环。</p>
<p>  <img src="http://algs4.cs.princeton.edu/23quicksort/images/partitioning-overview.png" alt="enter image description here"></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;<span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="comment">//从数组两侧进行扫描</span></div><div class="line">        <span class="keyword">while</span>(data[++i] &lt; compare) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;<span class="comment">//当左指针大于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">while</span> (compare &lt; data[--j]) <span class="keyword">if</span> (j == low) <span class="keyword">break</span>;<span class="comment">//当右指针小于compare的首元素时候，跳出进行交换</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;<span class="comment">//当左右指针相遇的时候，跳出循环体</span></div><div class="line">        <span class="comment">//元素交换</span></div><div class="line">        temp = data[i];</div><div class="line">        data[i] = data[j];</div><div class="line">        data[j] = temp;</div><div class="line">    &#125;</div><div class="line">    temp = data[low];</div><div class="line">    data[low] = data[j];</div><div class="line">    data[j] = temp;</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">    <span class="comment">//将首元素和位置[j]的元素进行交换</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="改善快速排序性能的简单方法"><a href="#改善快速排序性能的简单方法" class="headerlink" title="改善快速排序性能的简单方法"></a>改善快速排序性能的简单方法</h4><ul>
<li>类似于归并排序，对于小数组，插入排序的效率更高一些</li>
<li><p>由于递归的原因，排序方法也会在小数组当中调用自己</p>
</li>
<li><p>三取样切分</p>
<ul>
<li>通过使用子数组一部分元素的中位数来对数组进行切分。</li>
</ul>
</li>
</ul>
<h4 id="三向切分-熵最优排序"><a href="#三向切分-熵最优排序" class="headerlink" title="三向切分(熵最优排序)"></a>三向切分(熵最优排序)</h4><p>Example:</p>
<p><img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/quick-sort-3-way_d176ee.gif" alt="enter image description here"></p>
<p>该情况适用于数组当中存在大量重复元素的样例。当切分的元素重复的时候，不需要对其进行排序即可。切分的三部分分别为大于小于等于元素的数组元素</p>
<ul>
<li><code>data[i]</code> &lt; <code>compare</code>元素 二者交换 <code>i</code> 和 <code>lt</code>同时增加</li>
<li><code>data[i]</code> &gt; <code>compare</code>元素 和<code>data[gt]``交换</code>gt`减少</li>
<li><code>data[i]</code> = <code>compare</code>元素 <code>i++</code></li>
</ul>
<p>这样的操作能够保证数组元素不变，同时缩小<code>gt</code>-<code>i</code>的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threeWaySort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>; <span class="comment">//递归结束条件</span></div><div class="line">    <span class="keyword">int</span> lt = low, i = low + <span class="number">1</span>, gt = high; <span class="comment">//扫描指针</span></div><div class="line">    <span class="keyword">int</span> compare = data[low];</div><div class="line">    <span class="keyword">while</span> (i &lt;= gt)&#123;</div><div class="line">        <span class="keyword">if</span> (data[i] &lt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[lt];</div><div class="line">            data[lt] = temp;</div><div class="line">            i++;</div><div class="line">            lt++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; compare)&#123;</div><div class="line">            temp = data[i];</div><div class="line">            data[i] = data[gt];</div><div class="line">            data[gt] = temp;</div><div class="line">            gt--;</div><div class="line">        &#125;<span class="keyword">else</span> i++;</div><div class="line">    &#125;</div><div class="line">    threeWaySort(data, low, lt-<span class="number">1</span>);</div><div class="line">    threeWaySort(data, gt+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/heap-sort_f79bb1.gif" alt="enter image description here"></p>
</li>
</ul>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>二叉堆一种可以有效支持优先队列操作的数据结构。在二叉堆数组当中，每个元素都应该保证大于等于另外两个特定位置的元素，以此类推。二叉堆是一组能够用堆有序的完全二叉树排序的元素，其在数组当中按层级排列。</p>
<p>Example:</p>
<p><img src="http://algs4.cs.princeton.edu/24pq/images/heap-representations.png" alt="enter image description here"></p>
<h3 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h3><ul>
<li><p>通过使用优先队列构造排序方法，将所有的元素插入到查找最小元素的优先队列当中，堆排序主要包含两个部分，1. 将原始数组构造为有序堆 2. 不断将根节点移出树结构，同时重新构造有序堆。</p>
<ul>
<li><p>堆的构造</p>
<p>通过对数据从右至左进行不断的sink操作，对于数组中的每一个位置，都能够认为是每个子堆的根节点(也包含树的最底层节点)。对于扫描数组只需要扫描其容量的一半，这样可以跳过大小为1的子堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> N = data.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- ) &#123;</div><div class="line">        sink(data, i, N);<span class="comment">//该部分目的构造有序堆</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</div><div class="line">        exchange(data, <span class="number">1</span>, N--);</div><div class="line">        sink(data, <span class="number">1</span>, N);</div><div class="line">        <span class="comment">//移出每个堆中的最大元素，完成排序</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="排序算法复杂度总结"><a href="#排序算法复杂度总结" class="headerlink" title="排序算法复杂度总结"></a>排序算法复杂度总结</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316203033.jpg" alt="enter image description here"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Elementary Sorting]]></title>
      <url>http://yoursite.com/2016/11/28/Algorithm-Sorting/</url>
      <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法的目的是将数组元素的主键依照某种方式进行排序。排序后索引较大的主键大于或等于索引较小的主键。</p>
<p>在java当中，元素通常都是对象，对主键的抽象描述是通过一种内部构建的机制来完成的(java中的Comparable接口)</p>
<h3 id="比较函数的性质"><a href="#比较函数的性质" class="headerlink" title="比较函数的性质"></a>比较函数的性质</h3><p>比较函数需要满足如下性质才能是的排序函数正常执行：</p>
<ol>
<li>反对称性：a &lt;= b且b &lt;= a推出a = b</li>
<li>传递性：a &lt;= b且b &lt;= c推出a &lt;= c</li>
<li>整体性：存在a &lt;= b或者b &lt;= a或者二者同时存在</li>
</ol>
<a id="more"></a>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><ul>
<li><p>less: 判断两个相比较的元素是否存在小于关系</p>
</li>
<li><p>exchange：交换比较数组中的元素</p>
</li>
<li><p>顺序检查： 检查排序的数组是否已经完成排序</p>
</li>
</ul>
<h3 id="Template-of-Sorting-Algorithm"><a href="#Template-of-Sorting-Algorithm" class="headerlink" title="Template of Sorting Algorithm"></a>Template of Sorting Algorithm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">/* Code */</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> v.Comparable(w) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        Comparable t = a[i];</div><div class="line">        a[i] = a[j];</div><div class="line">        a[j] = t;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Print Array</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</div><div class="line">            System.out.println(a[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">        <span class="comment">// Test if the Array is sorted</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(less(a[i]), a[i-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String[] a = In.readString();</div><div class="line">        sort(a);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</div><div class="line">        show(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基本排序分类"><a href="#基本排序分类" class="headerlink" title="基本排序分类"></a>基本排序分类</h2><h3 id="冒泡排序-复杂度-O-n-2"><a href="#冒泡排序-复杂度-O-n-2" class="headerlink" title="冒泡排序(复杂度 O(n^2))"></a>冒泡排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/bubble-sort_ee720b.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  冒泡排序通过每次对需要排序的<code>item</code>的每一个相邻项进行比较，若前一个比后一个大，则进行交换。通过这个操作，每一趟排列可以将<code>item</code>中的最大值置于最高位，在经过<code>n-1</code>趟循环之后，排列结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="comment">//总共外部循环需要n-1次，每次迭代排序数组需要n-1次</span></div><div class="line">        <span class="comment">//同时需要考虑数据交换</span></div><div class="line">        <span class="comment">//冒泡排序每经过一次外层循环都可以把最高位归位</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=data.length-<span class="number">1</span>; j++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=data.length-<span class="number">1</span>-j; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (data[i-<span class="number">1</span>]&gt;data[i])&#123;</div><div class="line">                    temp = data[i-<span class="number">1</span>];</div><div class="line">                    data[i-<span class="number">1</span>] = data[i];</div><div class="line">                    data[i] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择排序-复杂度-O-n-2"><a href="#选择排序-复杂度-O-n-2" class="headerlink" title="选择排序(复杂度 O(n^2))"></a>选择排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/selection-sort_f03ab6.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  在数组中查询最小的元素，然后将其与数组中的第一个元素进行交换。当数组的第一个元素为最小元素的时候(将其与自身进行交换)。下一步在其余元素中找到最小的元素，将其与数组中的第二个元素进行交换。循环往复，直到将整个数组进行了排序。基本概念就是在剩余元素当中寻找最小者。</p>
</li>
<li><p>复杂度</p>
<p>  对于选择排序来说，当数组长度为<code>N</code>, 其大约需要<code>N^2/2</code>次比较与<code>N</code>次交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length-<span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="comment">//由于选择排序每经过一次外层循环，标记点的左侧为已完成排序的内容</span></div><div class="line">            <span class="keyword">int</span> min = i;<span class="comment">//设置初始标记点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; data.length; j++) &#123;</div><div class="line">                <span class="comment">//内层循环用于和标记点进行比较</span></div><div class="line">                <span class="keyword">if</span> (data[min] &gt; data[j])&#123;</div><div class="line">                    min = j;<span class="comment">//如果小于标记点，便替换标记点，当内层循环结束后，定位了此轮循环最小值的位置，跳出循环后将其</span></div><div class="line">                    <span class="comment">//初始标记点进行替换即可</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进行交换</span></div><div class="line">            <span class="keyword">int</span> temp = data[i];</div><div class="line">            data[i] = data[min];</div><div class="line">            data[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序-复杂度-O-n-2"><a href="#插入排序-复杂度-O-n-2" class="headerlink" title="插入排序(复杂度 O(n^2))"></a>插入排序(复杂度 O(n^2))</h3><ul>
<li><p>样例</p>
<p>  <img src="http://img.blog.csdn.net/20140602175214796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
</li>
<li><p>基本概念</p>
<p>  插入排序通过对索引左侧的数据进行不断的排列，使得索引左侧的数据保持有序，同时用未排序的数字和已排序的队列进行比较，当比它大，则进行交换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.length; i++)&#123;</div><div class="line">            <span class="comment">//内部循环是为了进行将对应指针左侧进行排列，并将较大的数字向右移动</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="keyword">if</span> (data[j]&lt;data[j-<span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = data[j-<span class="number">1</span>];</div><div class="line">                    data[j-<span class="number">1</span>] = data[j];</div><div class="line">                    data[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="希尔排序-复杂度介于O-nlogn到n-2"><a href="#希尔排序-复杂度介于O-nlogn到n-2" class="headerlink" title="希尔排序 复杂度介于O(nlogn到n^2)"></a>希尔排序 复杂度介于O(nlogn到n^2)</h3><ul>
<li><p>样例</p>
<p>  <img src="https://assets.toptal.io/assets/front/static/public/blocks/sorting_algorithms/animations/50/random-initial-order/shell-sort_5c15b3.gif" alt="enter image description here"></p>
</li>
<li><p>基本概念<br>  希尔排序是对于插入排序的一种优化，插入排序当数值较小的<code>key</code>排在靠后的位置时，排序的效率是比较低的，因为在应用插入排序的时候，它只会交换相邻元素。<br>  希尔排序通过交换不相邻元素的位置，使得较小的值能够被更快地移动到开头位置，其应用思想被称为<code>h</code>有序数组。<br>  <img src="http://algs4.cs.princeton.edu/21elementary/images/h-sorted.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &lt;= data.length) step = <span class="number">3</span>*step + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (step &gt;= <span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//此步先对外部循环进行判断，即每次step需要的运行次数</span></div><div class="line">            <span class="comment">//此处外部循环导致越界，尤其在数组边界的时候</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= step; j -= step)&#123;</div><div class="line">                    <span class="comment">//在交换时候考虑超过数组边界问题</span></div><div class="line">                    <span class="keyword">if</span> (data[j-step] &gt; data[j])&#123;</div><div class="line">                        <span class="keyword">int</span> temp = data[j-step];</div><div class="line">                        data[j-step] = data[j];</div><div class="line">                        data[j] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            step = step/<span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/21elementary/" target="_blank" rel="external">Princeton-Algorithm 4th, Sorting Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Data Structure-Stack]]></title>
      <url>http://yoursite.com/2016/11/24/Data%20Structure-Stack/</url>
      <content type="html"><![CDATA[<h2 id="Data-Structure-Princeton-Algorithm"><a href="#Data-Structure-Princeton-Algorithm" class="headerlink" title="Data Structure-Princeton Algorithm"></a>Data Structure-Princeton Algorithm</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><h4 id="Basic-API-of-Stack"><a href="#Basic-API-of-Stack" class="headerlink" title="Basic API of Stack"></a>Basic API of Stack</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;</span></div><div class="line"></div><div class="line"><span class="title">Stack</span><span class="params">()</span> <span class="comment">//创建空栈</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> <span class="comment">//向栈中添加元素</span></div><div class="line"></div><div class="line">Item <span class="title">pop</span><span class="params">()</span> <span class="comment">//从栈中删除最近添加元素</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 检测栈是否为空</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="comment">//栈中包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="Stack的实现方式"><a href="#Stack的实现方式" class="headerlink" title="Stack的实现方式"></a>Stack的实现方式</h2><ul>
<li><p>Linked_list</p>
<blockquote>
<p>定义： 链表是一种递归的数据结构，它可以为空(null)，也可以指向对一个节点的(node)的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。 结点可作为任意数据类型的抽象实体。</p>
</blockquote>
</li>
</ul>
<h3 id="Stack的linkedlist-实现"><a href="#Stack的linkedlist-实现" class="headerlink" title="Stack的linkedlist 实现"></a>Stack的linkedlist 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">inner <span class="class"><span class="keyword">class</span></span></div><div class="line"><span class="title">private</span> <span class="title">class</span> <span class="title">Node</span>&#123;</div><div class="line">    String item;</div><div class="line">    Node next;</div><div class="line">&#125;</div><div class="line"><span class="comment">//对节点进行初始化</span></div></pre></td></tr></table></figure>
<ul>
<li><p>Push 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-insert-front.png" alt="enter image description here"></p>
</li>
<li><p>Pop 操作</p>
<p>  <img src="http://algs4.cs.princeton.edu/13stacks/images/linked-list-remove-first.png" alt="enter image description here"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Node first;<span class="comment">// Initialize the first node of the linkedlist</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//number of items</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        String item;</div><div class="line">        Node next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> first == <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// or N == 0;</span></div><div class="line">        <span class="comment">//judge if the stack is empty</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</div><div class="line">        Node oldfirst = first;</div><div class="line">        <span class="comment">//将当前的首位赋值给临时的oldfirst</span></div><div class="line">        first = <span class="keyword">new</span> Node();</div><div class="line">        first.item = item;</div><div class="line">        <span class="comment">//将压入stack的item复制给新的first</span></div><div class="line">        first.next = oldfirst;</div><div class="line">        N++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        String item = first.item;</div><div class="line">        first = first.next;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Stack的Resizing-Array实现"><a href="#Stack的Resizing-Array实现" class="headerlink" title="Stack的Resizing Array实现"></a>Stack的Resizing Array实现</h3><ul>
<li>Array<blockquote>
<p>关于定容数组对于栈的实现, 在初始化栈的时候，必须要先设定栈的最大容量。同时数组一旦被创建，其大小便无法进行改变。当数组容量被设置过大的时候，又会浪费大量的内存。然而在用例过大的时候，也会很容易发生溢出问题，因此实现栈容量的动态调节是非常有必要的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizingArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];<span class="comment">// java不支持泛型数组，所以需要进行强制转换</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> N;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</div><div class="line">        <span class="comment">//将stack移动到大小为max的数组当中</span></div><div class="line">        Item[] temp = (Item[]) <span class="keyword">new</span> Object[max];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            temp[i] = a[i];</div><div class="line">        &#125;</div><div class="line">        a = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (N == a.length) &#123;</div><div class="line">            resize(<span class="number">2</span>*a.length);</div><div class="line">            a[N++] = item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        Item item = a[--N];</div><div class="line">        a[N] = <span class="keyword">null</span>;<span class="comment">//避免对象游离，成为“孤儿”</span></div><div class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N == a.length/<span class="number">4</span>) &#123;</div><div class="line">            resize(a.length/<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseArrayIterator();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = N;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> i &gt; <span class="number">0</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a[--i];&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对象游离<blockquote>
<p>java的GC策略是将所有无法被访问的对象的内存， 在上述Pop操作的代码当中，被弹出的元素的引用仍旧存在于数组当中。但是这个元素实际上已经成为一个“孤儿”， 即它永远不会再被访问了。 除非这个引用被覆盖，否则java的GC机制永远无法知道这点。因此为了避免出现这种现象，我们需要将弹出的元素设置为null，则这个用例可正常被作为垃圾进行回收。</p>
</blockquote>
</li>
</ul>
<h2 id="上述两种方式的比较"><a href="#上述两种方式的比较" class="headerlink" title="上述两种方式的比较"></a>上述两种方式的比较</h2><ul>
<li>Linkedlist<ul>
<li>最差情况下，每一步操作都要消耗恒定时间</li>
<li>需要花费额外的时间和空间对链接进行处理</li>
</ul>
</li>
<li>Resizing-Array<ul>
<li>每一步操作都需要花费平均的摊销时间</li>
<li>消耗更少量的空间</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/13stacks/" target="_blank" rel="external">Princeton-Algorithm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm-Union Find]]></title>
      <url>http://yoursite.com/2016/11/12/Union-Find-Algorithm/</url>
      <content type="html"><![CDATA[<h2 id="Princeton-Algorithm"><a href="#Princeton-Algorithm" class="headerlink" title="Princeton - Algorithm"></a>Princeton - Algorithm</h2><p>1st week：Union-Find</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有N个元素，从0~N-1编号，假如两个元素之间的连接视为通路，当执行多次任意的两个元素之间的连接之后，如何判断两个元素能够经由已有路径相连通。对于连接的动作称为union，判断是否连接的操作称为find，如下图<br><a id="more"></a><br><img src="http://obpbs8a3y.bkt.clouddn.com/1.jpg" alt="enter image description here"><br><img src="http://img.blog.csdn.net/20130901114328078" alt="enter image description here"></p>
<p>从上图中可以看出，0, 1, 2, 5, 6, 7 中的任意两个元素都是相连的，同样 3, 4, 8, 9 中任意两个元素也是互连的，但是第一个集合和第二个集合的元素却是无法连通的。</p>
<p>实际操作中可用于在一个庞大的网路环境下，如何迅速判断某两个点是否相连，如下图：</p>
<p><img src="http://i2.piimg.com/567571/38bfecc955fdf85c.jpg" alt="enter image description here"></p>
<h3 id="有效算法的开发步骤"><a href="#有效算法的开发步骤" class="headerlink" title="有效算法的开发步骤"></a>有效算法的开发步骤</h3><ol>
<li>构建需求模型</li>
<li>寻找所需算法</li>
<li>运行算法检测速度和内存是否符合要求</li>
<li>效率差或者达不到要求，找出问题的原因</li>
<li>寻求解决办法，循环上述步骤直到满意为止</li>
</ol>
<h3 id="首先确认Union和Find操作应该满足怎样的条件："><a href="#首先确认Union和Find操作应该满足怎样的条件：" class="headerlink" title="首先确认Union和Find操作应该满足怎样的条件："></a>首先确认Union和Find操作应该满足怎样的条件：</h3><p>find操作：确认两个对象是否连接：<br>自反性：P连接到Q<br>对称性：P连接到Q，则 Q连接到P<br>传递性：P连接到Q，Q连接到R，则P也连接到R</p>
<p>union操作：连接在一起的对象，我们统称为一个连接集合，执行一次union操作就相当于将两个对象所在的集合连接到一起，组成一个新的集合。新集合中的任意两个成员也应该都处于连接状态。</p>
<h3 id="Connected-Component"><a href="#Connected-Component" class="headerlink" title="Connected Component"></a>Connected Component</h3><p>Concept: 相连的节点所构成的集合</p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<p><img src="http://img.blog.csdn.net/20140531203442953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>并查集提供了两种操作：</p>
<ol>
<li>查找操作(find)：检测两个节点是否相连</li>
<li>合并操作(Union): 将两节点进行链接</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>并查集算法需要实现如下目标：</p>
<ol>
<li>查找对象的数量N可以非常大</li>
<li>操作的次数M可以非常大</li>
<li>Find和Union操作可以随意调用</li>
</ol>
<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>数据结构<br>假设有N个节点，该算法的数据结构为一个包含N个整数的数组id[]</p>
<h3 id="Find操作"><a href="#Find操作" class="headerlink" title="Find操作"></a>Find操作</h3><p>判断p q两个节点是否相连，通过判断id[p]和id[q]对应的数值是否一致</p>
<h3 id="Union操作"><a href="#Union操作" class="headerlink" title="Union操作"></a>Union操作</h3><p>将两节点合作是通过将被合并的节点q的id值设为节点p的id值</p>
<p>但是合并操作的缺点是在进行Union操作的时候，需要遍历整个数组，因此算法开销比较大</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>每一次合并的复杂度为N，当合并次数非常大的时候，趋近于N，运算的复杂度则为N^2,因此该算法不适合较大规模运算。</p>
<p>查找操作的复杂度为1.</p>
<h2 id="Quick-Union-Lazy-Approach"><a href="#Quick-Union-Lazy-Approach" class="headerlink" title="Quick Union(Lazy Approach)"></a>Quick Union(Lazy Approach)</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>整型数组id[],大小为N</li>
<li>Interpretation: 数组的每个元素id[i]指的是i的上一级为id[i]</li>
<li>i的根节点 id[id[id[…id[]…]]]</li>
</ol>
<h3 id="Find操作-1"><a href="#Find操作-1" class="headerlink" title="Find操作"></a>Find操作</h3><p>如果P和Q两个值对应相同的根节点，则为找到</p>
<h3 id="Union操作-1"><a href="#Union操作-1" class="headerlink" title="Union操作"></a>Union操作</h3><p>如果需要将p q进行连接，则需要将二者对应的根节点数设为相同值</p>
<p><img src="http://img.blog.csdn.net/20130901134321640" alt="enter image description here"></p>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>在最坏的情况下，查找操作的复杂度仍将达到N</p>
<h2 id="Quick-Union的优化"><a href="#Quick-Union的优化" class="headerlink" title="Quick Union的优化"></a>Quick Union的优化</h2><p>通过每个节点增加quality的概念，使得quality小的component位于大的component之下，从而避免了树形结构过高的问题。</p>
<p>如下图展示了树形结构深度优化后的效果<br><img src="http://img.blog.csdn.net/20140602174057171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpcGVpY2hhbzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>合并操作的最坏复杂度为lgN,查询操作的最坏复杂度为lgN</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>在查找根节点时，将路径上的所有节点进行路径压缩，理论上得到的find操作的复杂度为1.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HotKey of Intellij IDEA]]></title>
      <url>http://yoursite.com/2016/01/17/HotKey%20of%20Intellij%20IDEA/</url>
      <content type="html"><![CDATA[<p><em>Intellij IDEA作为一款能力非常强大的集成开发工具，为日常的程序开发带来了很大的便利，同时内部自带的快捷键也极大地提升了开发效率，本文将主要对Intellij IDEA中的常用快捷键进行总结</em><br><a id="more"></a></p>
<h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">Ctrl+E，最近的文件</div><div class="line">Ctrl+Shift+E，最近更改的文件</div><div class="line">Shift+Click，可以关闭文件</div><div class="line">Ctrl+[ OR ]，可以跑到大括号的开头与结尾</div><div class="line">Ctrl+F12，可以显示当前文件的结构</div><div class="line">Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择</div><div class="line">Ctrl+N，可以快速打开类</div><div class="line">Ctrl+Shift+N，可以快速打开文件</div><div class="line">Alt+Q，可以看到当前方法的声明</div><div class="line">Ctrl+P，可以显示参数信息</div><div class="line">Ctrl+Shift+Insert，可以选择剪贴板内容并插入</div><div class="line">Alt+Insert，可以生成构造器/Getter/Setter等</div><div class="line">Ctrl+Alt+V，可以引入变量。例如：new String();  自动导入变量定义</div><div class="line">Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch</div><div class="line">Ctrl+Enter，导入包，自动修正</div><div class="line">Ctrl+Alt+L，格式化代码</div><div class="line">Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作</div><div class="line">Ctrl+Alt+O，优化导入的类和包</div><div class="line">Ctrl+R，替换文本</div><div class="line">Ctrl+F，查找文本</div><div class="line">Ctrl+Shift+Space，自动补全代码</div><div class="line">Ctrl+空格，代码提示（与系统输入法快捷键冲突）</div><div class="line">Ctrl+Shift+Alt+N，查找类中的方法或变量</div><div class="line">Alt+Shift+C，最近的更改</div><div class="line">Alt+Shift+Up/Down，上/下移一行</div><div class="line">Shift+F6，重构 - 重命名</div><div class="line">Ctrl+X，删除行</div><div class="line">Ctrl+D，复制行</div><div class="line">Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）</div><div class="line">Ctrl+J，自动代码（例如：serr）</div><div class="line">Ctrl+Alt+J，用动态模板环绕</div><div class="line">Ctrl+H，显示类结构图（类的继承层次）</div><div class="line">Ctrl+Q，显示注释文档</div><div class="line">Alt+F1，查找代码所在位置</div><div class="line">Alt+1，快速打开或隐藏工程面板</div><div class="line">Ctrl+Alt+left/right，返回至上次浏览的位置</div><div class="line">Alt+left/right，切换代码视图</div><div class="line">Alt+Up/Down，在方法间快速移动定位</div><div class="line">Ctrl+Shift+Up/Down，向上/下移动语句</div><div class="line">F2 或 Shift+F2，高亮错误或警告快速定位</div><div class="line">Tab，代码标签输入完成后，按 Tab，生成代码</div><div class="line">Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失</div><div class="line">Alt+F3，逐个往下查找相同文本，并高亮显示</div><div class="line">Ctrl+Up/Down，光标中转到第一行或最后一行下</div><div class="line">Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）</div><div class="line">Ctrl+Alt+B，跳转到方法实现处</div><div class="line">Ctrl+Shift+Backspace，跳转到上次编辑的地方</div><div class="line">Ctrl+O，重写方法</div><div class="line">Ctrl+Alt+Space，类名自动完成</div><div class="line">Ctrl+Alt+Up/Down，快速跳转搜索结果</div><div class="line">Ctrl+Shift+J，整合两行</div><div class="line">Alt+F8，计算变量值</div><div class="line">Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本</div><div class="line">Ctrl+Alt+Shift+V，简单粘贴</div><div class="line">Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口</div><div class="line">F12，把焦点从编辑器移到最近使用的工具窗口</div><div class="line">Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器</div><div class="line">Ctrl+W，可以选择单词继而语句继而行继而函数</div><div class="line">Ctrl+Shift+W，取消选择光标所在词</div><div class="line">Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置</div><div class="line">Ctrl+I，实现方法</div><div class="line">Ctrl+Shift+U，大小写转化</div><div class="line">Ctrl+Y，删除当前行</div><div class="line">Shift+Enter，向下插入新行</div><div class="line">psvm/sout，main/System.out.println(); Ctrl+J，查看更多</div><div class="line">Ctrl+Shift+F，全局查找</div><div class="line">Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找</div><div class="line">Ctrl+Shift+S，高级搜索</div><div class="line">Ctrl+U，转到父类</div><div class="line">Ctrl+Alt+S，打开设置对话框</div><div class="line">Alt+Shift+Inert，开启/关闭列选择模式</div><div class="line">Ctrl+Alt+Shift+S，打开当前项目/模块属性</div><div class="line">Ctrl+G，定位行</div><div class="line">Alt+Home，跳转到导航栏</div><div class="line">Ctrl+Enter，上插一行</div><div class="line">Ctrl+Backspace，按单词删除</div><div class="line">Ctrl+&quot;+/-&quot;，当前方法展开、折叠</div><div class="line">Ctrl+Shift+&quot;+/-&quot;，全部展开、折叠</div></pre></td></tr></table></figure>
<h3 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="调试部分、编译"></a>调试部分、编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Ctrl+F2，停止</div><div class="line">Alt+Shift+F9，选择 Debug</div><div class="line">Alt+Shift+F10，选择 Run</div><div class="line">Ctrl+Shift+F9，编译</div><div class="line">Ctrl+Shift+F10，运行</div><div class="line">Ctrl+Shift+F8，查看断点</div><div class="line">F8，步过</div><div class="line">F7，步入</div><div class="line">Shift+F7，智能步入</div><div class="line">Shift+F8，步出</div><div class="line">Alt+Shift+F8，强制步过</div><div class="line">Alt+Shift+F7，强制步入</div><div class="line">Alt+F9，运行至光标处</div><div class="line">Ctrl+Alt+F9，强制运行至光标处</div><div class="line">F9，恢复程序</div><div class="line">Alt+F10，定位到断点</div><div class="line">Ctrl+F8，切换行断点</div><div class="line">Ctrl+F9，生成项目</div><div class="line">Alt+1，项目</div><div class="line">Alt+2，收藏</div><div class="line">Alt+6，TODO</div><div class="line">Alt+7，结构</div><div class="line">Ctrl+Shift+C，复制路径</div><div class="line">Ctrl+Alt+Shift+C，复制引用，必须选择类名</div><div class="line">Ctrl+Alt+Y，同步</div><div class="line">Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</div><div class="line">Shift+F12，还原默认布局</div><div class="line">Ctrl+Shift+F12，隐藏/恢复所有窗口</div><div class="line">Ctrl+F4，关闭</div><div class="line">Ctrl+Shift+F4，关闭活动选项卡</div><div class="line">Ctrl+Tab，转到下一个拆分器</div><div class="line">Ctrl+Shift+Tab，转到上一个拆分器</div></pre></td></tr></table></figure>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ctrl+Alt+Shift+T，弹出重构菜单</div><div class="line">Shift+F6，重命名</div><div class="line">F6，移动</div><div class="line">F5，复制</div><div class="line">Alt+Delete，安全删除</div><div class="line">Ctrl+Alt+N，内联</div></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Ctrl+F，查找</div><div class="line">Ctrl+R，替换</div><div class="line">F3，查找下一个</div><div class="line">Shift+F3，查找上一个</div><div class="line">Ctrl+Shift+F，在路径中查找</div><div class="line">Ctrl+Shift+R，在路径中替换</div><div class="line">Ctrl+Shift+S，搜索结构</div><div class="line">Ctrl+Shift+M，替换结构</div><div class="line">Alt+F7，查找用法</div><div class="line">Ctrl+Alt+F7，显示用法</div><div class="line">Ctrl+F7，在文件中查找用法</div><div class="line">Ctrl+Shift+F7，在文件中高亮显示用法</div></pre></td></tr></table></figure>
<h3 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alt+~，VCS 操作菜单</div><div class="line">Ctrl+K，提交更改</div><div class="line">Ctrl+T，更新项目</div><div class="line">Ctrl+Alt+Shift+D，显示变化</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
